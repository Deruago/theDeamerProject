#ifndef DEAMER_TEMPLATES_DLEG_LEXERSOURCETEMPLATE_h
#define DEAMER_TEMPLATES_DLEG_LEXERSOURCETEMPLATE_h

#include <string>
#include <variant>
#include <vector>

namespace deamer::templates::dleg
{
	/*!	\class LexerSourceTemplate
	 *
	 *	\brief Generates code for "LexerSourceTemplate"
	 *
	 *	\details This is generated by DST.
	 *	For more information visit: https://github.com/Deruago/DeamerStringTemplate
	 */
	class LexerSourceTemplate
	{
	public:
		enum class Type
		{
			Unknown,
			Scope,

			// User defined types
			alphabet_size_,
			ascii_size_,
			file_,
			language_name_,
			left_angle_bracket_,
			left_bracket_,
			left_curly_bracket_,
			optional_state_char_,
			optional_state_index_,
			out_state_,
			right_angle_bracket_,
			right_bracket_,
			right_curly_bracket_,
			state_bool_,
			state_char_,
			state_char_impl_,
			state_count_,
			state_enumeration_,
			state_id_,
			state_id_entry_,
			state_index_,
			state_index_impl_,
			state_name_,
			state_name_entry_,
			state_skip_,
			state_skip_default_,
			state_skip_delete_,
			state_skip_ignore_,
			state_skip_value_,
			state_transition_,
			state_transition_entry_,
			state_type_,
			state_type_accept_,
			state_type_empty_,
			state_type_reject_,

		};

		enum class ScopeType
		{
			Unknown,

			// Default
			Default_,
			Upper_,
			Lower_,

			Snake_,
			Slash_,
			BackSlash_,
			Colon_,
			DoubleColon_,

			Variable_Field_,
			Variable_Field_Separator_,
			Function_Field_,
			Function_Field_Separator_,

		};

		static constexpr const char*
		ConvertEnumToName(::deamer::templates::dleg::LexerSourceTemplate::Type enumerationValue)
		{
			switch (enumerationValue)
			{
			case ::deamer::templates::dleg::LexerSourceTemplate::Type::alphabet_size_: {
				return "alphabet_size";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::ascii_size_: {
				return "ascii_size";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::file_: {
				return "file";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::language_name_: {
				return "language_name";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::left_angle_bracket_: {
				return "left_angle_bracket";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::left_bracket_: {
				return "left_bracket";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::left_curly_bracket_: {
				return "left_curly_bracket";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::optional_state_char_: {
				return "optional_state_char";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::optional_state_index_: {
				return "optional_state_index";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::out_state_: {
				return "out_state";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::right_angle_bracket_: {
				return "right_angle_bracket";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::right_bracket_: {
				return "right_bracket";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::right_curly_bracket_: {
				return "right_curly_bracket";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_bool_: {
				return "state_bool";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_char_: {
				return "state_char";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_char_impl_: {
				return "state_char_impl";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_count_: {
				return "state_count";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_enumeration_: {
				return "state_enumeration";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_id_: {
				return "state_id";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_id_entry_: {
				return "state_id_entry";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_index_: {
				return "state_index";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_index_impl_: {
				return "state_index_impl";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_name_: {
				return "state_name";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_name_entry_: {
				return "state_name_entry";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_: {
				return "state_skip";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_default_: {
				return "state_skip_default";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_delete_: {
				return "state_skip_delete";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_ignore_: {
				return "state_skip_ignore";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_value_: {
				return "state_skip_value";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_transition_: {
				return "state_transition";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_transition_entry_: {
				return "state_transition_entry";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_: {
				return "state_type";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_accept_: {
				return "state_type_accept";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_empty_: {
				return "state_type_empty";
			}

			case ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_reject_: {
				return "state_type_reject";
			}
			}

			return "";
		}

	public:
		struct VariableBase
		{
			// The value is either a string
			// or a vector of variables.
			std::variant<std::string, std::vector<VariableBase*>> value;
			bool isString = true;

			::deamer::templates::dleg::LexerSourceTemplate::Type type =
				::deamer::templates::dleg::LexerSourceTemplate::Type::Unknown;

			VariableBase() : VariableBase(std::vector<VariableBase*>())
			{
			}

			virtual ~VariableBase() = default;

			VariableBase(const char* text)
			{
				isString = true;
				value = text;
			}

			VariableBase(const std::string& text)
			{
				isString = true;
				value = text;
			}

			VariableBase(std::vector<VariableBase*> variables)
			{
				isString = false;
				value = variables;
			}

			VariableBase* This()
			{
				return this;
			}

			virtual std::string GetValue()
			{
				if (isString)
				{
					return std::get<std::string>(value);
				}
				else
				{
					std::string output;
					auto& variables = std::get<std::vector<VariableBase*>>(value);
					for (auto* variable : variables)
					{
						output += variable->GetValue();
					}
					return output;
				}
			}

			std::string GetName()
			{
				return ConvertEnumToName(type);
			}

			VariableBase& operator=(const std::string& variable)
			{
				return Set(variable);
			}

			VariableBase& operator=(VariableBase* variable)
			{
				return Set(variable);
			}

			VariableBase& operator+=(VariableBase* variable)
			{
				return Add(variable);
			}

			VariableBase& operator+=(const std::string& variable)
			{
				return Add(variable);
			}

			VariableBase& Set(const std::string& variable)
			{
				value = variable;
				isString = true;

				return *this;
			}

			VariableBase& Set(VariableBase* variable)
			{
				if (variable == this)
				{
					return *this;
				}

				value = variable->value;
				isString = variable->isString;

				return *this;
			}

			VariableBase& Add(const std::string& variable)
			{
				if (isString)
				{
					auto& text = std::get<std::string>(value);
					text += variable;
					value = text;
				}
				else
				{
					auto& vector = std::get<std::vector<VariableBase*>>(value);
					vector.push_back(new VariableBase(variable));
					value = vector;
				}

				return *this;
			}

			VariableBase& Add(VariableBase* variable)
			{
				if (variable == this)
				{
					return *this;
				}

				if (isString)
				{
					// convert current -> variablebase
					// then create a vector.
					auto& currentValue = std::get<std::string>(value);
					auto* currentValueAsVariableBase = new VariableBase(currentValue);
					value = std::vector<VariableBase*>({currentValueAsVariableBase, variable});

					isString = false;
				}
				else
				{
					auto& vector = std::get<std::vector<VariableBase*>>(value);
					vector.push_back(variable);
					value = vector;
				}

				return *this;
			}

			void Clear()
			{
				if (isString)
				{
					value = "";
				}
				else
				{
					value = std::vector<VariableBase*>();
				}
			}

			void* operator new(size_t size)
			{
				void* newVariable = ::operator new(size);
				variables_to_delete.emplace_back(static_cast<VariableBase*>(newVariable));

				return newVariable;
			}
		};

		static VariableBase* GenerateVariable(VariableBase* variable)
		{
			return variable;
		}

		static VariableBase* GenerateVariable(const std::string& variable)
		{
			return new VariableBase(variable);
		}

		struct VariableScope : public VariableBase
		{
			::deamer::templates::dleg::LexerSourceTemplate::ScopeType scope_type =
				::deamer::templates::dleg::LexerSourceTemplate::ScopeType::Unknown;
			bool isReserved = false;

			VariableScope(::deamer::templates::dleg::LexerSourceTemplate::ScopeType scope_type_,
						  bool isReserved_ = false)
				: VariableBase(),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;
			}

			VariableScope(const char* text,
						  ::deamer::templates::dleg::LexerSourceTemplate::ScopeType scope_type_,
						  bool isReserved_ = false)
				: VariableBase(text),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;
			}

			VariableScope(std::vector<VariableBase*> variable,
						  ::deamer::templates::dleg::LexerSourceTemplate::ScopeType scope_type_,
						  bool isReserved_ = false)
				: VariableBase(variable),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;
			}
		};

		struct Variable_ReservedScope_Upper : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Upper(VariableBase* base_)
				: VariableScope(::deamer::templates::dleg::LexerSourceTemplate::ScopeType::Upper_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string upperVariant;
				std::string currentValue = base->GetValue();

				for (const auto character : currentValue)
				{
					upperVariant += std::toupper(character);
				}

				return upperVariant;
			}
		};

		struct Variable_ReservedScope_Lower : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Lower(VariableBase* base_)
				: VariableScope(::deamer::templates::dleg::LexerSourceTemplate::ScopeType::Lower_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string lowerVariant;
				std::string currentValue = base->GetValue();

				for (const auto character : currentValue)
				{
					lowerVariant += std::tolower(character);
				}

				return lowerVariant;
			}
		};

		struct Variable_ReservedScope_Snake : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Snake(VariableBase* base_)
				: VariableScope(::deamer::templates::dleg::LexerSourceTemplate::ScopeType::Snake_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string snakeVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						snakeVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						snakeVariant += '_';
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!snakeVariant.empty() && lastWasNonAlpha)
				{
					snakeVariant.pop_back();
				}

				return snakeVariant;
			}
		};

		struct Variable_ReservedScope_Slash : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Slash(VariableBase* base_)
				: VariableScope(::deamer::templates::dleg::LexerSourceTemplate::ScopeType::Slash_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string slashVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						slashVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						slashVariant += '/';
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!slashVariant.empty() && lastWasNonAlpha)
				{
					slashVariant.pop_back();
				}

				return slashVariant;
			}
		};

		struct Variable_ReservedScope_DoubleColon : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_DoubleColon(VariableBase* base_)
				: VariableScope(
					  ::deamer::templates::dleg::LexerSourceTemplate::ScopeType::DoubleColon_,
					  true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string doubleColonVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						doubleColonVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						doubleColonVariant += "::";
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!doubleColonVariant.empty() && lastWasNonAlpha)
				{
					doubleColonVariant.pop_back();
					doubleColonVariant.pop_back();
				}

				return doubleColonVariant;
			}
		};

		struct VariableScopes : public VariableBase
		{
			// Default scopes
			VariableBase* default_ = new VariableScope(
				::deamer::templates::dleg::LexerSourceTemplate::ScopeType::Default_, true);
			VariableBase* upper_ = new Variable_ReservedScope_Upper(this);
			VariableBase* lower_ = new Variable_ReservedScope_Lower(this);

			VariableBase* snake_ = new Variable_ReservedScope_Snake(this);
			VariableBase* slash_ = new Variable_ReservedScope_Slash(this);
			VariableBase* double_colon_ = new Variable_ReservedScope_DoubleColon(this);

			VariableBase* variable_field_ = new VariableScope(
				::deamer::templates::dleg::LexerSourceTemplate::ScopeType::Variable_Field_, true);
			VariableBase* variable_field_separator_ =
				new VariableScope("\n",
								  ::deamer::templates::dleg::LexerSourceTemplate::ScopeType::
									  Variable_Field_Separator_,
								  true);

			// Ctor
			VariableScopes() : VariableBase()
			{
			}

			VariableScopes(const char* text) : VariableBase(text)
			{
			}

			VariableScopes(const std::string& text) : VariableBase(text)
			{
			}

			VariableScopes(std::vector<VariableBase*> variables) : VariableBase(variables)
			{
			}

			// Dtor
			virtual ~VariableScopes() override = default;

			// Calls
			VariableBase* Default()
			{
				return default_;
			}
			VariableBase* Upper()
			{
				return upper_;
			}

			VariableBase* Lower()
			{
				return lower_;
			}

			VariableBase* Underscore()
			{
				return snake_;
			}

			VariableBase* Snake()
			{
				return snake_;
			}

			VariableBase* Slash()
			{
				return slash_;
			}

			VariableBase* DoubleColon()
			{
				return double_colon_;
			}

			VariableBase* Variable_Field()
			{
				return variable_field_;
			}

			VariableBase* Variable_Field_Separator()
			{
				return variable_field_separator_;
			}

			void ExpandVariableField()
			{
				// currentvalue + separator
				const auto currentValue = GetValue() + Variable_Field_Separator()->GetValue();
				*Variable_Field() += currentValue;
			}
		};

	public:
		struct Variable_alphabet_size_ : public VariableScopes
		{
			static constexpr auto name = "alphabet_size_";

			Variable_alphabet_size_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::alphabet_size_;
			}

			virtual ~Variable_alphabet_size_() override = default;

			Variable_alphabet_size_(LexerSourceTemplate* lexersourcetemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::alphabet_size_;
			}

			Variable_alphabet_size_& operator=(const Variable_alphabet_size_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_ascii_size_ : public VariableScopes
		{
			static constexpr auto name = "ascii_size_";

			Variable_ascii_size_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::ascii_size_;
			}

			virtual ~Variable_ascii_size_() override = default;

			Variable_ascii_size_(LexerSourceTemplate* lexersourcetemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::ascii_size_;
			}

			Variable_ascii_size_& operator=(const Variable_ascii_size_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_file_ : public VariableScopes
		{
			static constexpr auto name = "file_";

			VariableBase* Content_ = GenerateVariable("");
			VariableBase* Class_postfix_ = GenerateVariable("");
			VariableBase* Extension_ = GenerateVariable("");
			VariableBase* File_name_ = GenerateVariable("");
			VariableBase* Namespace_ = GenerateVariable("");
			VariableBase* Target_language_ = GenerateVariable("");

			Variable_file_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::file_;
			}

			virtual ~Variable_file_() override = default;

			Variable_file_(LexerSourceTemplate* lexersourcetemplate_,
						   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::file_;
				*static_cast<VariableBase*>(Content_) = VariableBase(std::vector<VariableBase*>(
					{GenerateVariable("#include \""),
					 GenerateVariable(lexersourcetemplate_->language_name_->This()),
					 GenerateVariable("/Dleg/Lexer"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include <vector>\n#include <string>\n\n/* Transition table"),
					 GenerateVariable("."),
					 GenerateVariable("\n * table[state_count][alphabet_size]\n * \n */\nstatic "
									  "constexpr unsigned table["),
					 GenerateVariable(lexersourcetemplate_->state_count_->This()),
					 GenerateVariable("]["),
					 GenerateVariable(lexersourcetemplate_->alphabet_size_->This()),
					 GenerateVariable("] = "),
					 GenerateVariable("{"),
					 GenerateVariable("\n"),
					 GenerateVariable(lexersourcetemplate_->state_transition_->Variable_Field()),
					 GenerateVariable("\n"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n/* State Type\n * - 0: Standard State (Non "
									  "Accepting)\n * - 1: Accept State\n * - 2: Reject State\n "
									  "*\n */\nstatic constexpr unsigned stateType["),
					 GenerateVariable(lexersourcetemplate_->state_count_->This()),
					 GenerateVariable("] = "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t"),
					 GenerateVariable(lexersourcetemplate_->state_type_->Variable_Field()),
					 GenerateVariable("\n"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n/* State Name\n * The Name of the accepted Terminal\n "
									  "*\n */\nstatic constexpr const char* stateName["),
					 GenerateVariable(lexersourcetemplate_->state_count_->This()),
					 GenerateVariable("] = "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t"),
					 GenerateVariable(lexersourcetemplate_->state_name_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n/* State Skip\n * The Terminal Type\n * - Standard "
									  "Terminal\n * - Valueless Terminal\n * - Deleted Terminal\n "
									  "*/\nstatic constexpr std::size_t stateSkipContent["),
					 GenerateVariable(lexersourcetemplate_->state_count_->This()),
					 GenerateVariable("] = "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t"),
					 GenerateVariable(lexersourcetemplate_->state_skip_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n/* State Id\n * The Terminal Id\n *\n */\nstatic "
									  "constexpr std::size_t stateId["),
					 GenerateVariable(lexersourcetemplate_->state_count_->This()),
					 GenerateVariable("] = "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t"),
					 GenerateVariable(lexersourcetemplate_->state_id_->Variable_Field()),
					 GenerateVariable("\n"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 ";\n\nstd::vector<const deamer::external::cpp::lexer::TerminalObject*> "),
					 GenerateVariable(lexersourcetemplate_->language_name_->This()),
					 GenerateVariable("::dleg::lexer::Lexer::Tokenize(const std::string& text, "
									  "::deamer::external::cpp::lexer::TerminalConstructionPolicy "
									  "constructionPolicy) const\n"),
					 GenerateVariable("{"),
					 GenerateVariable(
						 "\n\tstd::vector<const deamer::external::cpp::lexer::TerminalObject*> "
						 "outputTerminalObjects;\n\n\tauto c_str = text"),
					 GenerateVariable("."),
					 GenerateVariable("c_str();\n\tconst char* element = &c_str[0];\n\n\tint "
									  "line_number = 0;\n\tint column = 0;\n\tint new_column = "
									  "0;\n\n\tstd::string current_text;\n\tint current_state = 0; "
									  "// start state is 0\n\tauto reset = [&]()\n\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\tcurrent_text"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "clear();\n\t\tcurrent_state = 0;\t\n\t\tcolumn = new_column;\n\t"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n\tauto ConstructTerminal = [&]() "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\tswitch (stateSkipContent[current_state])\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\tcase 0: "),
					 GenerateVariable("{"),
					 GenerateVariable(" // Standard Terminal\n\t\t\toutputTerminalObjects"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(new "
						 "deamer::external::cpp::lexer::TerminalObject(\n\t\t\t\tcurrent_text, "
						 "line_number, column, stateId[current_state]));\n\t\t\tbreak;\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\tcase 1: "),
					 GenerateVariable("{"),
					 GenerateVariable(" // Valueless Terminal\n\t\t\tif (constructionPolicy == "
									  "::deamer::external::cpp::lexer::TerminalConstructionPolicy::"
									  "ignore_deleted_terminals)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\toutputTerminalObjects"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(new "
						 "deamer::external::cpp::lexer::TerminalObject(\n\t\t\t\t\t\"\", "
						 "line_number, column, stateId[current_state]));\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\toutputTerminalObjects"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(new "
						 "deamer::external::cpp::lexer::TerminalObject(\n\t\t\t\t\tcurrent_text, "
						 "line_number, column, stateId[current_state]));\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\tbreak;\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\tcase 2: "),
					 GenerateVariable("{"),
					 GenerateVariable(" // Deleted Token\n\t\t\tif (constructionPolicy == "
									  "::deamer::external::cpp::lexer::TerminalConstructionPolicy::"
									  "ignore_deleted_terminals)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// No Token Creation\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse if (constructionPolicy == "
									  "::deamer::external::cpp::lexer::TerminalConstructionPolicy::"
									  "include_deleted_terminals)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\toutputTerminalObjects"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(new "
						 "deamer::external::cpp::lexer::TerminalObject(\n\t\t\t\t\tcurrent_text, "
						 "line_number, column, stateId[current_state]));\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\tbreak;\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n\twhile (*element != '"),
					 GenerateVariable("\\"),
					 GenerateVariable("0')\n\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\tnew_column++;\n\t\t\n\t\tif (*element == '"),
					 GenerateVariable("\\"),
					 GenerateVariable("n')\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tline_number++;\n\t\t\tnew_column = 0;\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\tauto new_state = "
									  "table[current_state][static_cast<int>(*element)];\n\n\t\tif "
									  "(stateType[new_state] == "),
					 GenerateVariable(lexersourcetemplate_->state_type_reject_->This()),
					 GenerateVariable(")\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tnew_column--; // As the state is not "
									  "progressed\n\n\t\t\tif (stateType[current_state] == "),
					 GenerateVariable(lexersourcetemplate_->state_type_accept_->This()),
					 GenerateVariable(")\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tConstructTerminal();\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable(
						 "\n\t\t\t\tstd::cout << \"Unknown Sequence, internally resetting state"),
					 GenerateVariable("\\"),
					 GenerateVariable("n\";\n\n\t\t\t\tif (current_text"),
					 GenerateVariable("."),
					 GenerateVariable("empty())\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\tcurrent_text += *element;\n\t\t\t\t\t// Going "
									  "to next element as the element otherwise an infinite loop "
									  "occurs due to unrecognized patterns"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t\t\t\t\telement++;\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t\t\tif (constructionPolicy == "
									  "deamer::external::cpp::lexer::TerminalConstructionPolicy::"
									  "include_deleted_terminals)\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\t// Create terminal with unknown type to "
									  "indicate unrecognized sequence"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t\t\t\t\toutputTerminalObjects"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(new "
						 "deamer::external::cpp::lexer::TerminalObject(\n\t\t\t\t\tcurrent_text, "
						 "line_number, column, 0));\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\n\t\t\treset();\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\telse\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable(
						 "\n\t\t\t// No exit condition thus continuing\n\n\t\t\tcurrent_state = "
						 "new_state;\n\t\t\tcurrent_text += *element;\n\t\t\telement++;\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\n\tif (!current_text"),
					 GenerateVariable("."),
					 GenerateVariable("empty())\n\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\tif (stateType[current_state] == 1)\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tConstructTerminal();\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\treturn outputTerminalObjects;\n"),
					 GenerateVariable("}"),
					 GenerateVariable("\n")}));
				Content_->type = ::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;

				*static_cast<VariableBase*>(Class_postfix_) =
					VariableBase(std::vector<VariableBase*>({}));
				Class_postfix_->type = ::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;

				*static_cast<VariableBase*>(Extension_) =
					VariableBase(std::vector<VariableBase*>({GenerateVariable("h")}));
				Extension_->type = ::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;

				*static_cast<VariableBase*>(File_name_) =
					VariableBase(std::vector<VariableBase*>({GenerateVariable("LexerSource")}));
				File_name_->type = ::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;

				*static_cast<VariableBase*>(Namespace_) = VariableBase(
					std::vector<VariableBase*>({GenerateVariable("deamer::templates::dleg")}));
				Namespace_->type = ::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;

				*static_cast<VariableBase*>(Target_language_) =
					VariableBase(std::vector<VariableBase*>({GenerateVariable("C++")}));
				Target_language_->type =
					::deamer::templates::dleg::LexerSourceTemplate::Type::Scope;
			}

			VariableBase* Content() const
			{
				return Content_;
			}

			VariableBase* Class_postfix() const
			{
				return Class_postfix_;
			}

			VariableBase* Extension() const
			{
				return Extension_;
			}

			VariableBase* File_name() const
			{
				return File_name_;
			}

			VariableBase* Namespace() const
			{
				return Namespace_;
			}

			VariableBase* Target_language() const
			{
				return Target_language_;
			}

			Variable_file_& operator=(const Variable_file_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				*Content_ = *variable.Content_;
				*Class_postfix_ = *variable.Class_postfix_;
				*Extension_ = *variable.Extension_;
				*File_name_ = *variable.File_name_;
				*Namespace_ = *variable.Namespace_;
				*Target_language_ = *variable.Target_language_;

				return *this;
			}
		};

		struct Variable_language_name_ : public VariableScopes
		{
			static constexpr auto name = "language_name_";

			Variable_language_name_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::language_name_;
			}

			virtual ~Variable_language_name_() override = default;

			Variable_language_name_(LexerSourceTemplate* lexersourcetemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::language_name_;
			}

			Variable_language_name_& operator=(const Variable_language_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_angle_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_angle_bracket_";

			Variable_left_angle_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::left_angle_bracket_;
			}

			virtual ~Variable_left_angle_bracket_() override = default;

			Variable_left_angle_bracket_(LexerSourceTemplate* lexersourcetemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::left_angle_bracket_;
			}

			Variable_left_angle_bracket_& operator=(const Variable_left_angle_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_bracket_";

			Variable_left_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::left_bracket_;
			}

			virtual ~Variable_left_bracket_() override = default;

			Variable_left_bracket_(LexerSourceTemplate* lexersourcetemplate_,
								   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::left_bracket_;
			}

			Variable_left_bracket_& operator=(const Variable_left_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_curly_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_curly_bracket_";

			Variable_left_curly_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::left_curly_bracket_;
			}

			virtual ~Variable_left_curly_bracket_() override = default;

			Variable_left_curly_bracket_(LexerSourceTemplate* lexersourcetemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::left_curly_bracket_;
			}

			Variable_left_curly_bracket_& operator=(const Variable_left_curly_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_state_char_ : public VariableScopes
		{
			static constexpr auto name = "optional_state_char_";

			Variable_optional_state_char_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::optional_state_char_;
			}

			virtual ~Variable_optional_state_char_() override = default;

			Variable_optional_state_char_(LexerSourceTemplate* lexersourcetemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::optional_state_char_;
			}

			Variable_optional_state_char_& operator=(const Variable_optional_state_char_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_state_index_ : public VariableScopes
		{
			static constexpr auto name = "optional_state_index_";

			Variable_optional_state_index_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::optional_state_index_;
			}

			virtual ~Variable_optional_state_index_() override = default;

			Variable_optional_state_index_(LexerSourceTemplate* lexersourcetemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::optional_state_index_;
			}

			Variable_optional_state_index_&
			operator=(const Variable_optional_state_index_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_out_state_ : public VariableScopes
		{
			static constexpr auto name = "out_state_";

			Variable_out_state_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::out_state_;
			}

			virtual ~Variable_out_state_() override = default;

			Variable_out_state_(LexerSourceTemplate* lexersourcetemplate_,
								const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::out_state_;
			}

			Variable_out_state_& operator=(const Variable_out_state_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_angle_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_angle_bracket_";

			Variable_right_angle_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::right_angle_bracket_;
			}

			virtual ~Variable_right_angle_bracket_() override = default;

			Variable_right_angle_bracket_(LexerSourceTemplate* lexersourcetemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::right_angle_bracket_;
			}

			Variable_right_angle_bracket_& operator=(const Variable_right_angle_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_bracket_";

			Variable_right_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::right_bracket_;
			}

			virtual ~Variable_right_bracket_() override = default;

			Variable_right_bracket_(LexerSourceTemplate* lexersourcetemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::right_bracket_;
			}

			Variable_right_bracket_& operator=(const Variable_right_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_curly_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_curly_bracket_";

			Variable_right_curly_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::right_curly_bracket_;
			}

			virtual ~Variable_right_curly_bracket_() override = default;

			Variable_right_curly_bracket_(LexerSourceTemplate* lexersourcetemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::right_curly_bracket_;
			}

			Variable_right_curly_bracket_& operator=(const Variable_right_curly_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_bool_ : public VariableScopes
		{
			static constexpr auto name = "state_bool_";

			Variable_state_bool_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_bool_;
			}

			virtual ~Variable_state_bool_() override = default;

			Variable_state_bool_(LexerSourceTemplate* lexersourcetemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_bool_;
			}

			Variable_state_bool_& operator=(const Variable_state_bool_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_char_ : public VariableScopes
		{
			static constexpr auto name = "state_char_";

			Variable_state_char_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_char_;
			}

			virtual ~Variable_state_char_() override = default;

			Variable_state_char_(LexerSourceTemplate* lexersourcetemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_char_;
			}

			Variable_state_char_& operator=(const Variable_state_char_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_char_impl_ : public VariableScopes
		{
			static constexpr auto name = "state_char_impl_";

			Variable_state_char_impl_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_char_impl_;
			}

			virtual ~Variable_state_char_impl_() override = default;

			Variable_state_char_impl_(LexerSourceTemplate* lexersourcetemplate_,
									  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_char_impl_;
			}

			Variable_state_char_impl_& operator=(const Variable_state_char_impl_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_count_ : public VariableScopes
		{
			static constexpr auto name = "state_count_";

			Variable_state_count_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_count_;
			}

			virtual ~Variable_state_count_() override = default;

			Variable_state_count_(LexerSourceTemplate* lexersourcetemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_count_;
			}

			Variable_state_count_& operator=(const Variable_state_count_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_enumeration_ : public VariableScopes
		{
			static constexpr auto name = "state_enumeration_";

			Variable_state_enumeration_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_enumeration_;
			}

			virtual ~Variable_state_enumeration_() override = default;

			Variable_state_enumeration_(LexerSourceTemplate* lexersourcetemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_enumeration_;
			}

			Variable_state_enumeration_& operator=(const Variable_state_enumeration_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_id_ : public VariableScopes
		{
			static constexpr auto name = "state_id_";

			Variable_state_id_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_id_;
			}

			virtual ~Variable_state_id_() override = default;

			Variable_state_id_(LexerSourceTemplate* lexersourcetemplate_,
							   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_id_;
			}

			Variable_state_id_& operator=(const Variable_state_id_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_id_entry_ : public VariableScopes
		{
			static constexpr auto name = "state_id_entry_";

			Variable_state_id_entry_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_id_entry_;
			}

			virtual ~Variable_state_id_entry_() override = default;

			Variable_state_id_entry_(LexerSourceTemplate* lexersourcetemplate_,
									 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_id_entry_;
			}

			Variable_state_id_entry_& operator=(const Variable_state_id_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_index_ : public VariableScopes
		{
			static constexpr auto name = "state_index_";

			Variable_state_index_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_index_;
			}

			virtual ~Variable_state_index_() override = default;

			Variable_state_index_(LexerSourceTemplate* lexersourcetemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_index_;
			}

			Variable_state_index_& operator=(const Variable_state_index_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_index_impl_ : public VariableScopes
		{
			static constexpr auto name = "state_index_impl_";

			Variable_state_index_impl_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_index_impl_;
			}

			virtual ~Variable_state_index_impl_() override = default;

			Variable_state_index_impl_(LexerSourceTemplate* lexersourcetemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_index_impl_;
			}

			Variable_state_index_impl_& operator=(const Variable_state_index_impl_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_name_ : public VariableScopes
		{
			static constexpr auto name = "state_name_";

			Variable_state_name_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_name_;
			}

			virtual ~Variable_state_name_() override = default;

			Variable_state_name_(LexerSourceTemplate* lexersourcetemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_name_;
			}

			Variable_state_name_& operator=(const Variable_state_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_name_entry_ : public VariableScopes
		{
			static constexpr auto name = "state_name_entry_";

			Variable_state_name_entry_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_name_entry_;
			}

			virtual ~Variable_state_name_entry_() override = default;

			Variable_state_name_entry_(LexerSourceTemplate* lexersourcetemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_name_entry_;
			}

			Variable_state_name_entry_& operator=(const Variable_state_name_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_skip_ : public VariableScopes
		{
			static constexpr auto name = "state_skip_";

			Variable_state_skip_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_;
			}

			virtual ~Variable_state_skip_() override = default;

			Variable_state_skip_(LexerSourceTemplate* lexersourcetemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_;
			}

			Variable_state_skip_& operator=(const Variable_state_skip_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_skip_default_ : public VariableScopes
		{
			static constexpr auto name = "state_skip_default_";

			Variable_state_skip_default_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_default_;
			}

			virtual ~Variable_state_skip_default_() override = default;

			Variable_state_skip_default_(LexerSourceTemplate* lexersourcetemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_default_;
			}

			Variable_state_skip_default_& operator=(const Variable_state_skip_default_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_skip_delete_ : public VariableScopes
		{
			static constexpr auto name = "state_skip_delete_";

			Variable_state_skip_delete_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_delete_;
			}

			virtual ~Variable_state_skip_delete_() override = default;

			Variable_state_skip_delete_(LexerSourceTemplate* lexersourcetemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_delete_;
			}

			Variable_state_skip_delete_& operator=(const Variable_state_skip_delete_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_skip_ignore_ : public VariableScopes
		{
			static constexpr auto name = "state_skip_ignore_";

			Variable_state_skip_ignore_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_ignore_;
			}

			virtual ~Variable_state_skip_ignore_() override = default;

			Variable_state_skip_ignore_(LexerSourceTemplate* lexersourcetemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_ignore_;
			}

			Variable_state_skip_ignore_& operator=(const Variable_state_skip_ignore_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_skip_value_ : public VariableScopes
		{
			static constexpr auto name = "state_skip_value_";

			Variable_state_skip_value_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_value_;
			}

			virtual ~Variable_state_skip_value_() override = default;

			Variable_state_skip_value_(LexerSourceTemplate* lexersourcetemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_skip_value_;
			}

			Variable_state_skip_value_& operator=(const Variable_state_skip_value_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_transition_ : public VariableScopes
		{
			static constexpr auto name = "state_transition_";

			Variable_state_transition_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_transition_;
			}

			virtual ~Variable_state_transition_() override = default;

			Variable_state_transition_(LexerSourceTemplate* lexersourcetemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_transition_;
			}

			Variable_state_transition_& operator=(const Variable_state_transition_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_transition_entry_ : public VariableScopes
		{
			static constexpr auto name = "state_transition_entry_";

			Variable_state_transition_entry_() : VariableScopes()
			{
				type =
					::deamer::templates::dleg::LexerSourceTemplate::Type::state_transition_entry_;
			}

			virtual ~Variable_state_transition_entry_() override = default;

			Variable_state_transition_entry_(LexerSourceTemplate* lexersourcetemplate_,
											 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::deamer::templates::dleg::LexerSourceTemplate::Type::state_transition_entry_;
			}

			Variable_state_transition_entry_&
			operator=(const Variable_state_transition_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_type_ : public VariableScopes
		{
			static constexpr auto name = "state_type_";

			Variable_state_type_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_;
			}

			virtual ~Variable_state_type_() override = default;

			Variable_state_type_(LexerSourceTemplate* lexersourcetemplate_,
								 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_;
			}

			Variable_state_type_& operator=(const Variable_state_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_type_accept_ : public VariableScopes
		{
			static constexpr auto name = "state_type_accept_";

			Variable_state_type_accept_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_accept_;
			}

			virtual ~Variable_state_type_accept_() override = default;

			Variable_state_type_accept_(LexerSourceTemplate* lexersourcetemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_accept_;
			}

			Variable_state_type_accept_& operator=(const Variable_state_type_accept_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_type_empty_ : public VariableScopes
		{
			static constexpr auto name = "state_type_empty_";

			Variable_state_type_empty_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_empty_;
			}

			virtual ~Variable_state_type_empty_() override = default;

			Variable_state_type_empty_(LexerSourceTemplate* lexersourcetemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_empty_;
			}

			Variable_state_type_empty_& operator=(const Variable_state_type_empty_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_state_type_reject_ : public VariableScopes
		{
			static constexpr auto name = "state_type_reject_";

			Variable_state_type_reject_() : VariableScopes()
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_reject_;
			}

			virtual ~Variable_state_type_reject_() override = default;

			Variable_state_type_reject_(LexerSourceTemplate* lexersourcetemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::dleg::LexerSourceTemplate::Type::state_type_reject_;
			}

			Variable_state_type_reject_& operator=(const Variable_state_type_reject_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

	public:
		inline static std::vector<VariableBase*> variables_to_delete = std::vector<VariableBase*>();

	public:
		std::vector<VariableBase*> variables_;

	public:
		// Members that one can directly access.
		// e.g. LexerSourceTemplate.member = "auto-generated";
		Variable_alphabet_size_* alphabet_size_ = new Variable_alphabet_size_();
		Variable_ascii_size_* ascii_size_ = new Variable_ascii_size_();
		Variable_file_* file_ = new Variable_file_();
		Variable_language_name_* language_name_ = new Variable_language_name_();
		Variable_left_angle_bracket_* left_angle_bracket_ = new Variable_left_angle_bracket_();
		Variable_left_bracket_* left_bracket_ = new Variable_left_bracket_();
		Variable_left_curly_bracket_* left_curly_bracket_ = new Variable_left_curly_bracket_();
		Variable_optional_state_char_* optional_state_char_ = new Variable_optional_state_char_();
		Variable_optional_state_index_* optional_state_index_ =
			new Variable_optional_state_index_();
		Variable_out_state_* out_state_ = new Variable_out_state_();
		Variable_right_angle_bracket_* right_angle_bracket_ = new Variable_right_angle_bracket_();
		Variable_right_bracket_* right_bracket_ = new Variable_right_bracket_();
		Variable_right_curly_bracket_* right_curly_bracket_ = new Variable_right_curly_bracket_();
		Variable_state_bool_* state_bool_ = new Variable_state_bool_();
		Variable_state_char_* state_char_ = new Variable_state_char_();
		Variable_state_char_impl_* state_char_impl_ = new Variable_state_char_impl_();
		Variable_state_count_* state_count_ = new Variable_state_count_();
		Variable_state_enumeration_* state_enumeration_ = new Variable_state_enumeration_();
		Variable_state_id_* state_id_ = new Variable_state_id_();
		Variable_state_id_entry_* state_id_entry_ = new Variable_state_id_entry_();
		Variable_state_index_* state_index_ = new Variable_state_index_();
		Variable_state_index_impl_* state_index_impl_ = new Variable_state_index_impl_();
		Variable_state_name_* state_name_ = new Variable_state_name_();
		Variable_state_name_entry_* state_name_entry_ = new Variable_state_name_entry_();
		Variable_state_skip_* state_skip_ = new Variable_state_skip_();
		Variable_state_skip_default_* state_skip_default_ = new Variable_state_skip_default_();
		Variable_state_skip_delete_* state_skip_delete_ = new Variable_state_skip_delete_();
		Variable_state_skip_ignore_* state_skip_ignore_ = new Variable_state_skip_ignore_();
		Variable_state_skip_value_* state_skip_value_ = new Variable_state_skip_value_();
		Variable_state_transition_* state_transition_ = new Variable_state_transition_();
		Variable_state_transition_entry_* state_transition_entry_ =
			new Variable_state_transition_entry_();
		Variable_state_type_* state_type_ = new Variable_state_type_();
		Variable_state_type_accept_* state_type_accept_ = new Variable_state_type_accept_();
		Variable_state_type_empty_* state_type_empty_ = new Variable_state_type_empty_();
		Variable_state_type_reject_* state_type_reject_ = new Variable_state_type_reject_();

	public:
		LexerSourceTemplate()
		{
			*alphabet_size_ = Variable_alphabet_size_(
				this, std::vector<VariableBase*>({GenerateVariable(ascii_size_->This())}));
			*ascii_size_ =
				Variable_ascii_size_(this, std::vector<VariableBase*>({GenerateVariable("256")}));
			*file_ = Variable_file_(this, std::vector<VariableBase*>({}));
			*language_name_ = Variable_language_name_(this, std::vector<VariableBase*>({}));
			*left_angle_bracket_ = Variable_left_angle_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable("<")}));
			*left_bracket_ =
				Variable_left_bracket_(this, std::vector<VariableBase*>({GenerateVariable("{")}));
			*left_curly_bracket_ = Variable_left_curly_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable("(")}));
			*optional_state_char_ =
				Variable_optional_state_char_(this, std::vector<VariableBase*>({}));
			*optional_state_index_ = Variable_optional_state_index_(
				this, std::vector<VariableBase*>({GenerateVariable(state_index_impl_->This())}));
			*out_state_ = Variable_out_state_(this, std::vector<VariableBase*>({}));
			*right_angle_bracket_ = Variable_right_angle_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable(">")}));
			*right_bracket_ =
				Variable_right_bracket_(this, std::vector<VariableBase*>({GenerateVariable("}")}));
			*right_curly_bracket_ = Variable_right_curly_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable(")")}));
			*state_bool_ =
				Variable_state_bool_(this, std::vector<VariableBase*>({GenerateVariable("false")}));
			*state_char_ = Variable_state_char_(this, std::vector<VariableBase*>({}));
			*state_char_impl_ = Variable_state_char_impl_(
				this, std::vector<VariableBase*>({GenerateVariable("/*"),
												  GenerateVariable(state_char_->This()),
												  GenerateVariable("*/")}));
			*state_count_ = Variable_state_count_(this, std::vector<VariableBase*>({}));
			*state_enumeration_ = Variable_state_enumeration_(this, std::vector<VariableBase*>({}));
			*state_id_ = Variable_state_id_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(state_id_entry_->This()), GenerateVariable(", ")}));
			*state_id_entry_ = Variable_state_id_entry_(this, std::vector<VariableBase*>({}));
			*state_index_ = Variable_state_index_(this, std::vector<VariableBase*>({}));
			*state_index_impl_ = Variable_state_index_impl_(
				this, std::vector<VariableBase*>({GenerateVariable("/*"),
												  GenerateVariable(state_index_->This()),
												  GenerateVariable("*/")}));
			*state_name_ = Variable_state_name_(
				this, std::vector<VariableBase*>({GenerateVariable("\""),
												  GenerateVariable(state_name_entry_->This()),
												  GenerateVariable("\", ")}));
			*state_name_entry_ = Variable_state_name_entry_(this, std::vector<VariableBase*>({}));
			*state_skip_ = Variable_state_skip_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(state_skip_value_->This()), GenerateVariable(", ")}));
			*state_skip_default_ = Variable_state_skip_default_(
				this, std::vector<VariableBase*>({GenerateVariable("0")}));
			*state_skip_delete_ = Variable_state_skip_delete_(
				this, std::vector<VariableBase*>({GenerateVariable("2")}));
			*state_skip_ignore_ = Variable_state_skip_ignore_(
				this, std::vector<VariableBase*>({GenerateVariable("1")}));
			*state_skip_value_ = Variable_state_skip_value_(this, std::vector<VariableBase*>({}));
			*state_transition_ = Variable_state_transition_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\t"), GenerateVariable(optional_state_index_->This()),
						   GenerateVariable("\n\t"), GenerateVariable("{"), GenerateVariable(" "),
						   GenerateVariable(state_transition_entry_->Variable_Field()),
						   GenerateVariable(" "), GenerateVariable("}"), GenerateVariable(",")}));
			*state_transition_entry_ = Variable_state_transition_entry_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(" "), GenerateVariable(optional_state_char_->This()),
						   GenerateVariable(out_state_->This()), GenerateVariable(", ")}));
			*state_type_ = Variable_state_type_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable(state_enumeration_->This()), GenerateVariable(", ")}));
			*state_type_accept_ = Variable_state_type_accept_(
				this, std::vector<VariableBase*>({GenerateVariable("1")}));
			*state_type_empty_ = Variable_state_type_empty_(
				this, std::vector<VariableBase*>({GenerateVariable("0")}));
			*state_type_reject_ = Variable_state_type_reject_(
				this, std::vector<VariableBase*>({GenerateVariable("2")}));

			variables_.emplace_back(alphabet_size_);
			variables_.emplace_back(ascii_size_);
			variables_.emplace_back(file_);
			variables_.emplace_back(language_name_);
			variables_.emplace_back(left_angle_bracket_);
			variables_.emplace_back(left_bracket_);
			variables_.emplace_back(left_curly_bracket_);
			variables_.emplace_back(optional_state_char_);
			variables_.emplace_back(optional_state_index_);
			variables_.emplace_back(out_state_);
			variables_.emplace_back(right_angle_bracket_);
			variables_.emplace_back(right_bracket_);
			variables_.emplace_back(right_curly_bracket_);
			variables_.emplace_back(state_bool_);
			variables_.emplace_back(state_char_);
			variables_.emplace_back(state_char_impl_);
			variables_.emplace_back(state_count_);
			variables_.emplace_back(state_enumeration_);
			variables_.emplace_back(state_id_);
			variables_.emplace_back(state_id_entry_);
			variables_.emplace_back(state_index_);
			variables_.emplace_back(state_index_impl_);
			variables_.emplace_back(state_name_);
			variables_.emplace_back(state_name_entry_);
			variables_.emplace_back(state_skip_);
			variables_.emplace_back(state_skip_default_);
			variables_.emplace_back(state_skip_delete_);
			variables_.emplace_back(state_skip_ignore_);
			variables_.emplace_back(state_skip_value_);
			variables_.emplace_back(state_transition_);
			variables_.emplace_back(state_transition_entry_);
			variables_.emplace_back(state_type_);
			variables_.emplace_back(state_type_accept_);
			variables_.emplace_back(state_type_empty_);
			variables_.emplace_back(state_type_reject_);
		}

		virtual ~LexerSourceTemplate()
		{
			for (auto* variable : variables_to_delete)
			{
				delete variable;
			}

			variables_to_delete.clear();
		}

	public:
		// Default DST functions

		/*!	\fn GetOutput
		 *
		 *	\brief returns the output with the given the current state.
		 */
		std::string GetOutput()
		{
			return file_->Content()->GetValue();
		}

		/*!	\fn GetVariables
		 *
		 *	\brief Returns all top level variables known in this template.
		 */
		std::vector<VariableBase*> GetVariables()
		{
			return variables_;
		}

	public:
	};
}

#endif // DEAMER_TEMPLATES_DLEG_LEXERSOURCETEMPLATE_h
