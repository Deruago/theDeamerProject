#ifndef DEAMER_TEMPLATES_OOPSYNTAXRECOGNIZER_RECOGNIZERTEMPLATE_h
#define DEAMER_TEMPLATES_OOPSYNTAXRECOGNIZER_RECOGNIZERTEMPLATE_h

#include <string>
#include <variant>
#include <vector>

namespace deamer::templates::oopsyntaxrecognizer
{
	/*!	\class RecognizerTemplate
	 *
	 *	\brief Generates code for "RecognizerTemplate"
	 *
	 *	\details This is generated by DST.
	 *	For more information visit: https://github.com/Deruago/DeamerStringTemplate
	 */
	class RecognizerTemplate
	{
	public:
		enum class Type
		{
			Unknown,
			Scope,

			// User defined types
			ast_node_,
			basetype_object_,
			class_object_,
			direct_access_extension_call_,
			enum_object_,
			extended_direct_access_specialization_name_,
			file_,
			function_argument_,
			function_object_,
			header_guard_,
			impl_extended_direct_access_,
			impl_extended_direct_access_specialization_,
			impl_simple_direct_access_,
			interface_object_,
			language_name_,
			left_angle_bracket_,
			left_bracket_,
			left_curly_bracket_,
			listen_basetype_entry_,
			listen_basetype_exit_,
			listen_class_entry_,
			listen_class_exit_,
			listen_enumeration_entry_,
			listen_enumeration_exit_,
			listen_function_entry_,
			listen_function_exit_,
			listen_functionargument_entry_,
			listen_functionargument_exit_,
			listen_interface_entry_,
			listen_interface_exit_,
			listen_property_assign_any_name_,
			listen_property_assign_basetype_type_,
			listen_property_assign_class_name_,
			listen_property_assign_enum_member_,
			listen_property_assign_enum_name_,
			listen_property_assign_function_argument_name_,
			listen_property_assign_function_argument_type_,
			listen_property_assign_function_name_,
			listen_property_assign_function_returntype_,
			listen_property_assign_interface_name_,
			listen_property_assign_property_name_,
			listen_property_assign_property_type_,
			listen_property_assign_specific_production_rule_action_,
			listen_property_assign_specific_production_rule_action_logic_,
			listen_property_assign_struct_name_,
			listen_property_assignment_,
			listen_property_assignment_impl_,
			listen_property_entry_,
			listen_property_exit_,
			listen_struct_entry_,
			listen_struct_exit_,
			oopmodel_object_,
			optional_parent_continuation_,
			optional_parent_initializer_,
			parent_continuation_,
			parent_initializer_,
			property_assignment_conditional_,
			property_object_,
			required_ast_node_,
			required_production_rule_index_,
			right_angle_bracket_,
			right_bracket_,
			right_curly_bracket_,
			struct_object_,
			tool_type_namespace_,
			type_object_,

		};

		enum class ScopeType
		{
			Unknown,

			// Default
			Default_,
			Upper_,
			Lower_,

			Snake_,
			Slash_,
			BackSlash_,
			Colon_,
			DoubleColon_,

			Variable_Field_,
			Variable_Field_Separator_,
			Function_Field_,
			Function_Field_Separator_,

		};

		static constexpr const char* ConvertEnumToName(
			::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type enumerationValue)
		{
			switch (enumerationValue)
			{
			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Unknown: {
				return "Unknown";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope: {
				return "Scope";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::ast_node_: {
				return "ast_node";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				basetype_object_: {
				return "basetype_object";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				class_object_: {
				return "class_object";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				direct_access_extension_call_: {
				return "direct_access_extension_call";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::enum_object_: {
				return "enum_object";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				extended_direct_access_specialization_name_: {
				return "extended_direct_access_specialization_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::file_: {
				return "file";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				function_argument_: {
				return "function_argument";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				function_object_: {
				return "function_object";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				header_guard_: {
				return "header_guard";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				impl_extended_direct_access_: {
				return "impl_extended_direct_access";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				impl_extended_direct_access_specialization_: {
				return "impl_extended_direct_access_specialization";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				impl_simple_direct_access_: {
				return "impl_simple_direct_access";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				interface_object_: {
				return "interface_object";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				language_name_: {
				return "language_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				left_angle_bracket_: {
				return "left_angle_bracket";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				left_bracket_: {
				return "left_bracket";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				left_curly_bracket_: {
				return "left_curly_bracket";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_basetype_entry_: {
				return "listen_basetype_entry";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_basetype_exit_: {
				return "listen_basetype_exit";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_class_entry_: {
				return "listen_class_entry";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_class_exit_: {
				return "listen_class_exit";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_enumeration_entry_: {
				return "listen_enumeration_entry";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_enumeration_exit_: {
				return "listen_enumeration_exit";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_function_entry_: {
				return "listen_function_entry";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_function_exit_: {
				return "listen_function_exit";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_functionargument_entry_: {
				return "listen_functionargument_entry";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_functionargument_exit_: {
				return "listen_functionargument_exit";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_interface_entry_: {
				return "listen_interface_entry";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_interface_exit_: {
				return "listen_interface_exit";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_any_name_: {
				return "listen_property_assign_any_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_basetype_type_: {
				return "listen_property_assign_basetype_type";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_class_name_: {
				return "listen_property_assign_class_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_enum_member_: {
				return "listen_property_assign_enum_member";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_enum_name_: {
				return "listen_property_assign_enum_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_function_argument_name_: {
				return "listen_property_assign_function_argument_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_function_argument_type_: {
				return "listen_property_assign_function_argument_type";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_function_name_: {
				return "listen_property_assign_function_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_function_returntype_: {
				return "listen_property_assign_function_returntype";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_interface_name_: {
				return "listen_property_assign_interface_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_property_name_: {
				return "listen_property_assign_property_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_property_type_: {
				return "listen_property_assign_property_type";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_specific_production_rule_action_: {
				return "listen_property_assign_specific_production_rule_action";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_specific_production_rule_action_logic_: {
				return "listen_property_assign_specific_production_rule_action_logic";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assign_struct_name_: {
				return "listen_property_assign_struct_name";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assignment_: {
				return "listen_property_assignment";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_assignment_impl_: {
				return "listen_property_assignment_impl";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_entry_: {
				return "listen_property_entry";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_property_exit_: {
				return "listen_property_exit";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_struct_entry_: {
				return "listen_struct_entry";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				listen_struct_exit_: {
				return "listen_struct_exit";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				oopmodel_object_: {
				return "oopmodel_object";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				optional_parent_continuation_: {
				return "optional_parent_continuation";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				optional_parent_initializer_: {
				return "optional_parent_initializer";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				parent_continuation_: {
				return "parent_continuation";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				parent_initializer_: {
				return "parent_initializer";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				property_assignment_conditional_: {
				return "property_assignment_conditional";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				property_object_: {
				return "property_object";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				required_ast_node_: {
				return "required_ast_node";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				required_production_rule_index_: {
				return "required_production_rule_index";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				right_angle_bracket_: {
				return "right_angle_bracket";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				right_bracket_: {
				return "right_bracket";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				right_curly_bracket_: {
				return "right_curly_bracket";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				struct_object_: {
				return "struct_object";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
				tool_type_namespace_: {
				return "tool_type_namespace";
			}

			case ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::type_object_: {
				return "type_object";
			}
			}

			return "";
		}

	public:
		struct VariableBase
		{
			// The value is either a string
			// or a vector of variables.
			std::variant<std::string, std::vector<VariableBase*>> value;
			bool isString = true;

			::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type type =
				::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Unknown;

			VariableBase() : VariableBase(std::vector<VariableBase*>())
			{
			}

			virtual ~VariableBase() = default;

			VariableBase(const char* text)
			{
				isString = true;
				value = text;
			}

			VariableBase(const std::string& text)
			{
				isString = true;
				value = text;
			}

			VariableBase(std::vector<VariableBase*> variables)
			{
				isString = false;
				value = variables;
			}

			VariableBase* This()
			{
				return this;
			}

			virtual std::string GetValue()
			{
				if (isString)
				{
					return std::get<std::string>(value);
				}
				else
				{
					std::string output;
					auto& variables = std::get<std::vector<VariableBase*>>(value);
					for (auto* variable : variables)
					{
						output += variable->GetValue();
					}
					return output;
				}
			}

			std::string GetName()
			{
				return ConvertEnumToName(type);
			}

			VariableBase& operator=(const std::string& variable)
			{
				return Set(variable);
			}

			VariableBase& operator=(VariableBase* variable)
			{
				return Set(variable);
			}

			VariableBase& operator+=(VariableBase* variable)
			{
				return Add(variable);
			}

			VariableBase& operator+=(const std::string& variable)
			{
				return Add(variable);
			}

			VariableBase& Set(const std::string& variable)
			{
				value = variable;
				isString = true;

				return *this;
			}

			VariableBase& Set(VariableBase* variable)
			{
				if (variable == this)
				{
					return *this;
				}

				value = variable->value;
				isString = variable->isString;

				return *this;
			}

			VariableBase& Add(const std::string& variable)
			{
				if (isString)
				{
					auto& text = std::get<std::string>(value);
					text += variable;
					value = text;
				}
				else
				{
					auto& vector = std::get<std::vector<VariableBase*>>(value);
					vector.push_back(new VariableBase(variable));
					value = vector;
				}

				return *this;
			}

			VariableBase& Add(VariableBase* variable)
			{
				if (variable == this)
				{
					return *this;
				}

				if (isString)
				{
					// convert current -> variablebase
					// then create a vector.
					auto& currentValue = std::get<std::string>(value);
					auto* currentValueAsVariableBase = new VariableBase(currentValue);
					value = std::vector<VariableBase*>({currentValueAsVariableBase, variable});

					isString = false;
				}
				else
				{
					auto& vector = std::get<std::vector<VariableBase*>>(value);
					vector.push_back(variable);
					value = vector;
				}

				return *this;
			}

			void Clear()
			{
				if (isString)
				{
					value = "";
				}
				else
				{
					value = std::vector<VariableBase*>();
				}
			}

			void* operator new(size_t size)
			{
				void* newVariable = ::operator new(size);
				variables_to_delete.emplace_back(static_cast<VariableBase*>(newVariable));

				return newVariable;
			}
		};

		static VariableBase* GenerateVariable(VariableBase* variable)
		{
			return variable;
		}

		static VariableBase* GenerateVariable(const std::string& variable)
		{
			return new VariableBase(variable);
		}

		struct VariableScope : public VariableBase
		{
			::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::ScopeType scope_type =
				::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::ScopeType::Unknown;
			bool isReserved = false;

			VariableScope(
				::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::ScopeType scope_type_,
				bool isReserved_ = false)
				: VariableBase(),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;
			}

			VariableScope(
				const char* text,
				::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::ScopeType scope_type_,
				bool isReserved_ = false)
				: VariableBase(text),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;
			}

			VariableScope(
				std::vector<VariableBase*> variable,
				::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::ScopeType scope_type_,
				bool isReserved_ = false)
				: VariableBase(variable),
				  scope_type(scope_type_),
				  isReserved(isReserved_)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;
			}
		};

		struct Variable_ReservedScope_Upper : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Upper(VariableBase* base_)
				: VariableScope(::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::
									ScopeType::Upper_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string upperVariant;
				std::string currentValue = base->GetValue();

				for (const auto character : currentValue)
				{
					upperVariant += std::toupper(character);
				}

				return upperVariant;
			}
		};

		struct Variable_ReservedScope_Lower : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Lower(VariableBase* base_)
				: VariableScope(::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::
									ScopeType::Lower_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string lowerVariant;
				std::string currentValue = base->GetValue();

				for (const auto character : currentValue)
				{
					lowerVariant += std::tolower(character);
				}

				return lowerVariant;
			}
		};

		struct Variable_ReservedScope_Snake : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Snake(VariableBase* base_)
				: VariableScope(::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::
									ScopeType::Snake_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string snakeVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						snakeVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						snakeVariant += '_';
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!snakeVariant.empty() && lastWasNonAlpha)
				{
					snakeVariant.pop_back();
				}

				return snakeVariant;
			}
		};

		struct Variable_ReservedScope_Slash : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Slash(VariableBase* base_)
				: VariableScope(::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::
									ScopeType::Slash_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string slashVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						slashVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						slashVariant += '/';
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!slashVariant.empty() && lastWasNonAlpha)
				{
					slashVariant.pop_back();
				}

				return slashVariant;
			}
		};

		struct Variable_ReservedScope_DoubleColon : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_DoubleColon(VariableBase* base_)
				: VariableScope(::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::
									ScopeType::DoubleColon_,
								true),
				  base(base_)
			{
			}

			virtual std::string GetValue() override
			{
				std::string doubleColonVariant;
				std::string currentValue = base->GetValue();

				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						doubleColonVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}

						doubleColonVariant += "::";
						lastWasNonAlpha = true;
					}
				}

				// If it contains text
				// remove the tail
				if (!doubleColonVariant.empty() && lastWasNonAlpha)
				{
					doubleColonVariant.pop_back();
					doubleColonVariant.pop_back();
				}

				return doubleColonVariant;
			}
		};

		struct VariableScopes : public VariableBase
		{
			// Default scopes
			VariableBase* default_ = new VariableScope(
				::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::ScopeType::Default_,
				true);
			VariableBase* upper_ = new Variable_ReservedScope_Upper(this);
			VariableBase* lower_ = new Variable_ReservedScope_Lower(this);

			VariableBase* snake_ = new Variable_ReservedScope_Snake(this);
			VariableBase* slash_ = new Variable_ReservedScope_Slash(this);
			VariableBase* double_colon_ = new Variable_ReservedScope_DoubleColon(this);

			VariableBase* variable_field_ =
				new VariableScope(::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::
									  ScopeType::Variable_Field_,
								  true);
			VariableBase* variable_field_separator_ =
				new VariableScope("\n",
								  ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::
									  ScopeType::Variable_Field_Separator_,
								  true);

			// Ctor
			VariableScopes() : VariableBase()
			{
			}

			VariableScopes(const char* text) : VariableBase(text)
			{
			}

			VariableScopes(const std::string& text) : VariableBase(text)
			{
			}

			VariableScopes(std::vector<VariableBase*> variables) : VariableBase(variables)
			{
			}

			// Dtor
			virtual ~VariableScopes() override = default;

			// Calls
			VariableBase* Default()
			{
				return default_;
			}
			VariableBase* Upper()
			{
				return upper_;
			}

			VariableBase* Lower()
			{
				return lower_;
			}

			VariableBase* Underscore()
			{
				return snake_;
			}

			VariableBase* Snake()
			{
				return snake_;
			}

			VariableBase* Slash()
			{
				return slash_;
			}

			VariableBase* DoubleColon()
			{
				return double_colon_;
			}

			VariableBase* Variable_Field()
			{
				return variable_field_;
			}

			VariableBase* Variable_Field_Separator()
			{
				return variable_field_separator_;
			}

			void ExpandVariableField()
			{
				// currentvalue + separator
				const auto currentValue = GetValue() + Variable_Field_Separator()->GetValue();
				*Variable_Field() += currentValue;
			}
		};

	public:
		struct Variable_ast_node_ : public VariableScopes
		{
			static constexpr auto name = "ast_node_";

			Variable_ast_node_() : VariableScopes()
			{
				type =
					::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::ast_node_;
			}

			virtual ~Variable_ast_node_() override = default;

			Variable_ast_node_(RecognizerTemplate* recognizertemplate_,
							   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type =
					::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::ast_node_;
			}

			Variable_ast_node_& operator=(const Variable_ast_node_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_basetype_object_ : public VariableScopes
		{
			static constexpr auto name = "basetype_object_";

			Variable_basetype_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					basetype_object_;
			}

			virtual ~Variable_basetype_object_() override = default;

			Variable_basetype_object_(RecognizerTemplate* recognizertemplate_,
									  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					basetype_object_;
			}

			Variable_basetype_object_& operator=(const Variable_basetype_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_class_object_ : public VariableScopes
		{
			static constexpr auto name = "class_object_";

			Variable_class_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					class_object_;
			}

			virtual ~Variable_class_object_() override = default;

			Variable_class_object_(RecognizerTemplate* recognizertemplate_,
								   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					class_object_;
			}

			Variable_class_object_& operator=(const Variable_class_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_direct_access_extension_call_ : public VariableScopes
		{
			static constexpr auto name = "direct_access_extension_call_";

			Variable_direct_access_extension_call_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					direct_access_extension_call_;
			}

			virtual ~Variable_direct_access_extension_call_() override = default;

			Variable_direct_access_extension_call_(RecognizerTemplate* recognizertemplate_,
												   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					direct_access_extension_call_;
			}

			Variable_direct_access_extension_call_&
			operator=(const Variable_direct_access_extension_call_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_enum_object_ : public VariableScopes
		{
			static constexpr auto name = "enum_object_";

			Variable_enum_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					enum_object_;
			}

			virtual ~Variable_enum_object_() override = default;

			Variable_enum_object_(RecognizerTemplate* recognizertemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					enum_object_;
			}

			Variable_enum_object_& operator=(const Variable_enum_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_extended_direct_access_specialization_name_ : public VariableScopes
		{
			static constexpr auto name = "extended_direct_access_specialization_name_";

			Variable_extended_direct_access_specialization_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					extended_direct_access_specialization_name_;
			}

			virtual ~Variable_extended_direct_access_specialization_name_() override = default;

			Variable_extended_direct_access_specialization_name_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					extended_direct_access_specialization_name_;
			}

			Variable_extended_direct_access_specialization_name_&
			operator=(const Variable_extended_direct_access_specialization_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_file_ : public VariableScopes
		{
			static constexpr auto name = "file_";

			VariableBase* Content_ = GenerateVariable("");
			VariableBase* Class_postfix_ = GenerateVariable("");
			VariableBase* Extension_ = GenerateVariable("");
			VariableBase* File_name_ = GenerateVariable("");
			VariableBase* Namespace_ = GenerateVariable("");
			VariableBase* Target_language_ = GenerateVariable("");

			Variable_file_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::file_;
			}

			virtual ~Variable_file_() override = default;

			Variable_file_(RecognizerTemplate* recognizertemplate_,
						   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::file_;
				*static_cast<VariableBase*>(Content_) = VariableBase(std::vector<VariableBase*>(
					{GenerateVariable("#ifndef "),
					 GenerateVariable(recognizertemplate_->header_guard_->This()),
					 GenerateVariable("\n#define "),
					 GenerateVariable(recognizertemplate_->header_guard_->This()),
					 GenerateVariable("\n\n#include \""),
					 GenerateVariable(recognizertemplate_->language_name_->This()),
					 GenerateVariable("/Ast/Listener/EnterExitListener"),
					 GenerateVariable("."),
					 GenerateVariable("h\"\n#include \""),
					 GenerateVariable(recognizertemplate_->language_name_->This()),
					 GenerateVariable("/Ast/Reference/Access"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/AccessModifier"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/BaseTypeObject"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/ClassObject"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/EnumObject"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/FunctionArgument"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/FunctionObject"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/InterfaceObject"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/OopModel"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/PropertyObject"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/StructObject"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include \"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/Type"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "h\"\n#include "
						 "\"Deamer/External/Cpp/Tool/OopSyntaxRecognizer/Type/TypeCategory"),
					 GenerateVariable("."),
					 GenerateVariable("h\"\n#include <string>\n#include <vector>\n\nnamespace "),
					 GenerateVariable(recognizertemplate_->language_name_->This()),
					 GenerateVariable("::ast::listener::tool::oopsyntaxrecognizer\n"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t/*!\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("class Recognizer\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("brief Used to recognize OOP Concepts"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t *\n\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("details The Recognizer utilizes a Flavoring + DUPR "
									  "tactic\n\t *\tfor recognizing OOP concepts via syntax"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "\n\t *\tThis recognizer was\tcreated using the OOP Syntax LPD"),
					 GenerateVariable("."),
					 GenerateVariable("\n\t */\n\tclass Recognizer : public EnterExitListener\n\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\tpublic:\n\t\tRecognizer() : EnterExitListener()\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tunknown_type = new "),
					 GenerateVariable(recognizertemplate_->type_object_->This()),
					 GenerateVariable("("),
					 GenerateVariable(recognizertemplate_->tool_type_namespace_->This()),
					 GenerateVariable("TypeCategory::unknown, \"__unknown\");\n\t\t\tcreatedTypes"),
					 GenerateVariable("."),
					 GenerateVariable("push_back(unknown_type);\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\tprivate:\n\n\t\tenum class FlavorType\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable(
						 "\n\t\t\tunknown,\n\n\t\t\tClass,\n\t\t\tBaseType,\n\t\t\tStruct,"
						 "\n\t\t\tInterface,\n\t\t\tEnum,\n\t\t\tFunction,\n\t\t\tFunctionArgument,"
						 "\n\t\t\tProperty,\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n\n\t\t"),
					 GenerateVariable(recognizertemplate_->type_object_->This()),
					 GenerateVariable("* unknown_type = nullptr;\n\n\t\tstd::vector<"),
					 GenerateVariable(recognizertemplate_->type_object_->This()),
					 GenerateVariable("*> createdTypes;\n\t\tstd::vector<"),
					 GenerateVariable(recognizertemplate_->function_object_->This()),
					 GenerateVariable("*> globalFunctions;\n\t\tstd::vector<"),
					 GenerateVariable(recognizertemplate_->property_object_->This()),
					 GenerateVariable("*> globalProperties;\n\n\t\tstd::vector<"),
					 GenerateVariable(recognizertemplate_->function_object_->This()),
					 GenerateVariable("*> createdFunctions; // All functions\n\t\tstd::vector<"),
					 GenerateVariable(recognizertemplate_->function_argument_->This()),
					 GenerateVariable("*> createdFunctionsArguments;\n\t\tstd::vector<"),
					 GenerateVariable(recognizertemplate_->basetype_object_->This()),
					 GenerateVariable(
						 "*> createdBaseTypes;\n\n\t\t// Allow checking existence of "
						 "Flavors\n\t\tstd::size_t ClassFlavor = 0;\n\t\tstd::size_t "
						 "BaseTypeFlavor = 0;\n\t\tstd::size_t PropertyFlavor = "
						 "0;\n\t\tstd::size_t EnumFlavor = 0;\n\t\tstd::size_t StructFlavor = "
						 "0;\n\t\tstd::size_t InterfaceFlavor = 0;\n\t\tstd::size_t FunctionFlavor "
						 "= 0;\n\t\tstd::size_t FunctionArgumentFlavor = "
						 "0;\n\n\t\tstd::vector<FlavorType> FlavorStack;\n\n\t\t"),
					 GenerateVariable(recognizertemplate_->class_object_->This()),
					 GenerateVariable("* currentClassObject = nullptr;\n\t\t"),
					 GenerateVariable(recognizertemplate_->basetype_object_->This()),
					 GenerateVariable("* currentBaseTypeObject = nullptr;\n\t\t"),
					 GenerateVariable(recognizertemplate_->struct_object_->This()),
					 GenerateVariable("* currentStructObject = nullptr;\n\t\t"),
					 GenerateVariable(recognizertemplate_->interface_object_->This()),
					 GenerateVariable("* currentInterfaceObject = nullptr;\n\t\t"),
					 GenerateVariable(recognizertemplate_->property_object_->This()),
					 GenerateVariable("* currentPropertyObject = nullptr;\n\t\t"),
					 GenerateVariable(recognizertemplate_->enum_object_->This()),
					 GenerateVariable("* currentEnumObject = nullptr;\n\t\t"),
					 GenerateVariable(recognizertemplate_->function_object_->This()),
					 GenerateVariable("* currentFunctionObject = nullptr;\n\t\t"),
					 GenerateVariable(recognizertemplate_->function_argument_->This()),
					 GenerateVariable("* currentFunctionArgumentObject = nullptr;\n\n\t\t/*!\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("fn GetTopOfFlavorStack\n\t\t *\n\t\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("brief Get top of the Flavor stack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "\n\t\t *\tIf no flavor has been given returns unknown flavor"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "\n\t\t */\n\t\tFlavorType GetTopOfFlavorStack() const\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tif (FlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable("empty())\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\treturn FlavorType::unknown;\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t\treturn FlavorStack[FlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable("size() - 1];\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t/*!\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("fn GetType\n\t\t *\n\t\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable(
						 "brief Returns type if it exists, otherwise nullptr\n\t\t */\n\t\t"),
					 GenerateVariable(recognizertemplate_->type_object_->This()),
					 GenerateVariable("* GetType(const std::string& typeName) const\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tconst auto iter "
									  "=\n\t\t\t\tstd::find_if(std::cbegin(createdTypes), "
									  "std::cend(createdTypes),\n\t\t\t\t\t\t\t [typeName](const "),
					 GenerateVariable(recognizertemplate_->type_object_->This()),
					 GenerateVariable("* const type) "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\t\t\t\t return type != nullptr && "
									  "type->GetTypeName() == typeName;\n\t\t\t\t\t\t\t "),
					 GenerateVariable("}"),
					 GenerateVariable(");\n\n\t\t\tif (iter == std::end(createdTypes))\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\treturn unknown_type;\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t\treturn *iter;\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 "\n\n\t\t// NonTerminals introducing Concept Scope Flavors\n\t\t// The "
						 "Concept Flavors control the object construction\n"),
					 GenerateVariable(recognizertemplate_->listen_class_entry_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(recognizertemplate_->listen_class_exit_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_basetype_entry_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(recognizertemplate_->listen_basetype_exit_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(recognizertemplate_->listen_struct_entry_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(recognizertemplate_->listen_struct_exit_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_interface_entry_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_interface_exit_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_function_entry_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(recognizertemplate_->listen_function_exit_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_enumeration_entry_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_enumeration_exit_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_functionargument_entry_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_functionargument_exit_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_property_entry_->Variable_Field()),
					 GenerateVariable("\n\n"),
					 GenerateVariable(recognizertemplate_->listen_property_exit_->Variable_Field()),
					 GenerateVariable("\n\n\t\t// NonTerminals and Terminals initializing Concept "
									  "Properties\n\t\t// These NTs and Ts control the property "
									  "value mechanic\n"),
					 GenerateVariable(
						 recognizertemplate_->listen_property_assignment_->Variable_Field()),
					 GenerateVariable("\n\n\tpublic:\n\t\t/*!\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("fn GetOutput\n\t\t *\n\t\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable(
						 "brief Converts the output into a OopModel\n\t\t *\n\t\t *\t"),
					 GenerateVariable("\\"),
					 GenerateVariable("note This resets the listener\n\t\t */\n\t\t"),
					 GenerateVariable(recognizertemplate_->oopmodel_object_->This()),
					 GenerateVariable(" GetOutput()\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\treturn "),
					 GenerateVariable(recognizertemplate_->oopmodel_object_->This()),
					 GenerateVariable(
						 "(createdTypes, globalFunctions, createdTypes, "
						 "createdFunctions,\n\t\t\t\t\t\t\tcreatedFunctionsArguments);\n\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t"),
					 GenerateVariable("}"),
					 GenerateVariable(";\n"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n#endif // "),
					 GenerateVariable(recognizertemplate_->header_guard_->This()),
					 GenerateVariable("\n")}));
				Content_->type =
					::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;

				*static_cast<VariableBase*>(Class_postfix_) =
					VariableBase(std::vector<VariableBase*>({}));
				Class_postfix_->type =
					::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;

				*static_cast<VariableBase*>(Extension_) =
					VariableBase(std::vector<VariableBase*>({GenerateVariable("h")}));
				Extension_->type =
					::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;

				*static_cast<VariableBase*>(File_name_) =
					VariableBase(std::vector<VariableBase*>({GenerateVariable("Recognizer")}));
				File_name_->type =
					::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;

				*static_cast<VariableBase*>(Namespace_) = VariableBase(std::vector<VariableBase*>(
					{GenerateVariable("deamer::templates::oopsyntaxrecognizer")}));
				Namespace_->type =
					::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;

				*static_cast<VariableBase*>(Target_language_) =
					VariableBase(std::vector<VariableBase*>({GenerateVariable("C++")}));
				Target_language_->type =
					::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::Scope;
			}

			VariableBase* Content() const
			{
				return Content_;
			}

			VariableBase* Class_postfix() const
			{
				return Class_postfix_;
			}

			VariableBase* Extension() const
			{
				return Extension_;
			}

			VariableBase* File_name() const
			{
				return File_name_;
			}

			VariableBase* Namespace() const
			{
				return Namespace_;
			}

			VariableBase* Target_language() const
			{
				return Target_language_;
			}

			Variable_file_& operator=(const Variable_file_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				*Content_ = *variable.Content_;
				*Class_postfix_ = *variable.Class_postfix_;
				*Extension_ = *variable.Extension_;
				*File_name_ = *variable.File_name_;
				*Namespace_ = *variable.Namespace_;
				*Target_language_ = *variable.Target_language_;

				return *this;
			}
		};

		struct Variable_function_argument_ : public VariableScopes
		{
			static constexpr auto name = "function_argument_";

			Variable_function_argument_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					function_argument_;
			}

			virtual ~Variable_function_argument_() override = default;

			Variable_function_argument_(RecognizerTemplate* recognizertemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					function_argument_;
			}

			Variable_function_argument_& operator=(const Variable_function_argument_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_function_object_ : public VariableScopes
		{
			static constexpr auto name = "function_object_";

			Variable_function_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					function_object_;
			}

			virtual ~Variable_function_object_() override = default;

			Variable_function_object_(RecognizerTemplate* recognizertemplate_,
									  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					function_object_;
			}

			Variable_function_object_& operator=(const Variable_function_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_header_guard_ : public VariableScopes
		{
			static constexpr auto name = "header_guard_";

			Variable_header_guard_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					header_guard_;
			}

			virtual ~Variable_header_guard_() override = default;

			Variable_header_guard_(RecognizerTemplate* recognizertemplate_,
								   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					header_guard_;
			}

			Variable_header_guard_& operator=(const Variable_header_guard_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_impl_extended_direct_access_ : public VariableScopes
		{
			static constexpr auto name = "impl_extended_direct_access_";

			Variable_impl_extended_direct_access_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					impl_extended_direct_access_;
			}

			virtual ~Variable_impl_extended_direct_access_() override = default;

			Variable_impl_extended_direct_access_(RecognizerTemplate* recognizertemplate_,
												  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					impl_extended_direct_access_;
			}

			Variable_impl_extended_direct_access_&
			operator=(const Variable_impl_extended_direct_access_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_impl_extended_direct_access_specialization_ : public VariableScopes
		{
			static constexpr auto name = "impl_extended_direct_access_specialization_";

			Variable_impl_extended_direct_access_specialization_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					impl_extended_direct_access_specialization_;
			}

			virtual ~Variable_impl_extended_direct_access_specialization_() override = default;

			Variable_impl_extended_direct_access_specialization_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					impl_extended_direct_access_specialization_;
			}

			Variable_impl_extended_direct_access_specialization_&
			operator=(const Variable_impl_extended_direct_access_specialization_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_impl_simple_direct_access_ : public VariableScopes
		{
			static constexpr auto name = "impl_simple_direct_access_";

			Variable_impl_simple_direct_access_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					impl_simple_direct_access_;
			}

			virtual ~Variable_impl_simple_direct_access_() override = default;

			Variable_impl_simple_direct_access_(RecognizerTemplate* recognizertemplate_,
												const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					impl_simple_direct_access_;
			}

			Variable_impl_simple_direct_access_&
			operator=(const Variable_impl_simple_direct_access_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_interface_object_ : public VariableScopes
		{
			static constexpr auto name = "interface_object_";

			Variable_interface_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					interface_object_;
			}

			virtual ~Variable_interface_object_() override = default;

			Variable_interface_object_(RecognizerTemplate* recognizertemplate_,
									   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					interface_object_;
			}

			Variable_interface_object_& operator=(const Variable_interface_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_language_name_ : public VariableScopes
		{
			static constexpr auto name = "language_name_";

			Variable_language_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					language_name_;
			}

			virtual ~Variable_language_name_() override = default;

			Variable_language_name_(RecognizerTemplate* recognizertemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					language_name_;
			}

			Variable_language_name_& operator=(const Variable_language_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_angle_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_angle_bracket_";

			Variable_left_angle_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					left_angle_bracket_;
			}

			virtual ~Variable_left_angle_bracket_() override = default;

			Variable_left_angle_bracket_(RecognizerTemplate* recognizertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					left_angle_bracket_;
			}

			Variable_left_angle_bracket_& operator=(const Variable_left_angle_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_bracket_";

			Variable_left_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					left_bracket_;
			}

			virtual ~Variable_left_bracket_() override = default;

			Variable_left_bracket_(RecognizerTemplate* recognizertemplate_,
								   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					left_bracket_;
			}

			Variable_left_bracket_& operator=(const Variable_left_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_left_curly_bracket_ : public VariableScopes
		{
			static constexpr auto name = "left_curly_bracket_";

			Variable_left_curly_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					left_curly_bracket_;
			}

			virtual ~Variable_left_curly_bracket_() override = default;

			Variable_left_curly_bracket_(RecognizerTemplate* recognizertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					left_curly_bracket_;
			}

			Variable_left_curly_bracket_& operator=(const Variable_left_curly_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_basetype_entry_ : public VariableScopes
		{
			static constexpr auto name = "listen_basetype_entry_";

			Variable_listen_basetype_entry_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_basetype_entry_;
			}

			virtual ~Variable_listen_basetype_entry_() override = default;

			Variable_listen_basetype_entry_(RecognizerTemplate* recognizertemplate_,
											const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_basetype_entry_;
			}

			Variable_listen_basetype_entry_&
			operator=(const Variable_listen_basetype_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_basetype_exit_ : public VariableScopes
		{
			static constexpr auto name = "listen_basetype_exit_";

			Variable_listen_basetype_exit_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_basetype_exit_;
			}

			virtual ~Variable_listen_basetype_exit_() override = default;

			Variable_listen_basetype_exit_(RecognizerTemplate* recognizertemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_basetype_exit_;
			}

			Variable_listen_basetype_exit_&
			operator=(const Variable_listen_basetype_exit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_class_entry_ : public VariableScopes
		{
			static constexpr auto name = "listen_class_entry_";

			Variable_listen_class_entry_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_class_entry_;
			}

			virtual ~Variable_listen_class_entry_() override = default;

			Variable_listen_class_entry_(RecognizerTemplate* recognizertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_class_entry_;
			}

			Variable_listen_class_entry_& operator=(const Variable_listen_class_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_class_exit_ : public VariableScopes
		{
			static constexpr auto name = "listen_class_exit_";

			Variable_listen_class_exit_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_class_exit_;
			}

			virtual ~Variable_listen_class_exit_() override = default;

			Variable_listen_class_exit_(RecognizerTemplate* recognizertemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_class_exit_;
			}

			Variable_listen_class_exit_& operator=(const Variable_listen_class_exit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_enumeration_entry_ : public VariableScopes
		{
			static constexpr auto name = "listen_enumeration_entry_";

			Variable_listen_enumeration_entry_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_enumeration_entry_;
			}

			virtual ~Variable_listen_enumeration_entry_() override = default;

			Variable_listen_enumeration_entry_(RecognizerTemplate* recognizertemplate_,
											   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_enumeration_entry_;
			}

			Variable_listen_enumeration_entry_&
			operator=(const Variable_listen_enumeration_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_enumeration_exit_ : public VariableScopes
		{
			static constexpr auto name = "listen_enumeration_exit_";

			Variable_listen_enumeration_exit_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_enumeration_exit_;
			}

			virtual ~Variable_listen_enumeration_exit_() override = default;

			Variable_listen_enumeration_exit_(RecognizerTemplate* recognizertemplate_,
											  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_enumeration_exit_;
			}

			Variable_listen_enumeration_exit_&
			operator=(const Variable_listen_enumeration_exit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_function_entry_ : public VariableScopes
		{
			static constexpr auto name = "listen_function_entry_";

			Variable_listen_function_entry_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_function_entry_;
			}

			virtual ~Variable_listen_function_entry_() override = default;

			Variable_listen_function_entry_(RecognizerTemplate* recognizertemplate_,
											const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_function_entry_;
			}

			Variable_listen_function_entry_&
			operator=(const Variable_listen_function_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_function_exit_ : public VariableScopes
		{
			static constexpr auto name = "listen_function_exit_";

			Variable_listen_function_exit_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_function_exit_;
			}

			virtual ~Variable_listen_function_exit_() override = default;

			Variable_listen_function_exit_(RecognizerTemplate* recognizertemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_function_exit_;
			}

			Variable_listen_function_exit_&
			operator=(const Variable_listen_function_exit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_functionargument_entry_ : public VariableScopes
		{
			static constexpr auto name = "listen_functionargument_entry_";

			Variable_listen_functionargument_entry_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_functionargument_entry_;
			}

			virtual ~Variable_listen_functionargument_entry_() override = default;

			Variable_listen_functionargument_entry_(RecognizerTemplate* recognizertemplate_,
													const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_functionargument_entry_;
			}

			Variable_listen_functionargument_entry_&
			operator=(const Variable_listen_functionargument_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_functionargument_exit_ : public VariableScopes
		{
			static constexpr auto name = "listen_functionargument_exit_";

			Variable_listen_functionargument_exit_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_functionargument_exit_;
			}

			virtual ~Variable_listen_functionargument_exit_() override = default;

			Variable_listen_functionargument_exit_(RecognizerTemplate* recognizertemplate_,
												   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_functionargument_exit_;
			}

			Variable_listen_functionargument_exit_&
			operator=(const Variable_listen_functionargument_exit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_interface_entry_ : public VariableScopes
		{
			static constexpr auto name = "listen_interface_entry_";

			Variable_listen_interface_entry_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_interface_entry_;
			}

			virtual ~Variable_listen_interface_entry_() override = default;

			Variable_listen_interface_entry_(RecognizerTemplate* recognizertemplate_,
											 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_interface_entry_;
			}

			Variable_listen_interface_entry_&
			operator=(const Variable_listen_interface_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_interface_exit_ : public VariableScopes
		{
			static constexpr auto name = "listen_interface_exit_";

			Variable_listen_interface_exit_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_interface_exit_;
			}

			virtual ~Variable_listen_interface_exit_() override = default;

			Variable_listen_interface_exit_(RecognizerTemplate* recognizertemplate_,
											const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_interface_exit_;
			}

			Variable_listen_interface_exit_&
			operator=(const Variable_listen_interface_exit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_any_name_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_any_name_";

			Variable_listen_property_assign_any_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_any_name_;
			}

			virtual ~Variable_listen_property_assign_any_name_() override = default;

			Variable_listen_property_assign_any_name_(RecognizerTemplate* recognizertemplate_,
													  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_any_name_;
			}

			Variable_listen_property_assign_any_name_&
			operator=(const Variable_listen_property_assign_any_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_basetype_type_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_basetype_type_";

			Variable_listen_property_assign_basetype_type_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_basetype_type_;
			}

			virtual ~Variable_listen_property_assign_basetype_type_() override = default;

			Variable_listen_property_assign_basetype_type_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_basetype_type_;
			}

			Variable_listen_property_assign_basetype_type_&
			operator=(const Variable_listen_property_assign_basetype_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_class_name_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_class_name_";

			Variable_listen_property_assign_class_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_class_name_;
			}

			virtual ~Variable_listen_property_assign_class_name_() override = default;

			Variable_listen_property_assign_class_name_(RecognizerTemplate* recognizertemplate_,
														const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_class_name_;
			}

			Variable_listen_property_assign_class_name_&
			operator=(const Variable_listen_property_assign_class_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_enum_member_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_enum_member_";

			Variable_listen_property_assign_enum_member_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_enum_member_;
			}

			virtual ~Variable_listen_property_assign_enum_member_() override = default;

			Variable_listen_property_assign_enum_member_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_enum_member_;
			}

			Variable_listen_property_assign_enum_member_&
			operator=(const Variable_listen_property_assign_enum_member_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_enum_name_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_enum_name_";

			Variable_listen_property_assign_enum_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_enum_name_;
			}

			virtual ~Variable_listen_property_assign_enum_name_() override = default;

			Variable_listen_property_assign_enum_name_(RecognizerTemplate* recognizertemplate_,
													   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_enum_name_;
			}

			Variable_listen_property_assign_enum_name_&
			operator=(const Variable_listen_property_assign_enum_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_function_argument_name_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_function_argument_name_";

			Variable_listen_property_assign_function_argument_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_function_argument_name_;
			}

			virtual ~Variable_listen_property_assign_function_argument_name_() override = default;

			Variable_listen_property_assign_function_argument_name_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_function_argument_name_;
			}

			Variable_listen_property_assign_function_argument_name_&
			operator=(const Variable_listen_property_assign_function_argument_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_function_argument_type_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_function_argument_type_";

			Variable_listen_property_assign_function_argument_type_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_function_argument_type_;
			}

			virtual ~Variable_listen_property_assign_function_argument_type_() override = default;

			Variable_listen_property_assign_function_argument_type_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_function_argument_type_;
			}

			Variable_listen_property_assign_function_argument_type_&
			operator=(const Variable_listen_property_assign_function_argument_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_function_name_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_function_name_";

			Variable_listen_property_assign_function_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_function_name_;
			}

			virtual ~Variable_listen_property_assign_function_name_() override = default;

			Variable_listen_property_assign_function_name_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_function_name_;
			}

			Variable_listen_property_assign_function_name_&
			operator=(const Variable_listen_property_assign_function_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_function_returntype_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_function_returntype_";

			Variable_listen_property_assign_function_returntype_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_function_returntype_;
			}

			virtual ~Variable_listen_property_assign_function_returntype_() override = default;

			Variable_listen_property_assign_function_returntype_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_function_returntype_;
			}

			Variable_listen_property_assign_function_returntype_&
			operator=(const Variable_listen_property_assign_function_returntype_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_interface_name_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_interface_name_";

			Variable_listen_property_assign_interface_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_interface_name_;
			}

			virtual ~Variable_listen_property_assign_interface_name_() override = default;

			Variable_listen_property_assign_interface_name_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_interface_name_;
			}

			Variable_listen_property_assign_interface_name_&
			operator=(const Variable_listen_property_assign_interface_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_property_name_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_property_name_";

			Variable_listen_property_assign_property_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_property_name_;
			}

			virtual ~Variable_listen_property_assign_property_name_() override = default;

			Variable_listen_property_assign_property_name_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_property_name_;
			}

			Variable_listen_property_assign_property_name_&
			operator=(const Variable_listen_property_assign_property_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_property_type_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_property_type_";

			Variable_listen_property_assign_property_type_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_property_type_;
			}

			virtual ~Variable_listen_property_assign_property_type_() override = default;

			Variable_listen_property_assign_property_type_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_property_type_;
			}

			Variable_listen_property_assign_property_type_&
			operator=(const Variable_listen_property_assign_property_type_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_specific_production_rule_action_
			: public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_specific_production_rule_action_";

			Variable_listen_property_assign_specific_production_rule_action_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_specific_production_rule_action_;
			}

			virtual ~Variable_listen_property_assign_specific_production_rule_action_() override =
				default;

			Variable_listen_property_assign_specific_production_rule_action_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_specific_production_rule_action_;
			}

			Variable_listen_property_assign_specific_production_rule_action_& operator=(
				const Variable_listen_property_assign_specific_production_rule_action_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_specific_production_rule_action_logic_
			: public VariableScopes
		{
			static constexpr auto name =
				"listen_property_assign_specific_production_rule_action_logic_";

			Variable_listen_property_assign_specific_production_rule_action_logic_()
				: VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_specific_production_rule_action_logic_;
			}

			virtual ~Variable_listen_property_assign_specific_production_rule_action_logic_()
				override = default;

			Variable_listen_property_assign_specific_production_rule_action_logic_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_specific_production_rule_action_logic_;
			}

			Variable_listen_property_assign_specific_production_rule_action_logic_&
			operator=(const Variable_listen_property_assign_specific_production_rule_action_logic_&
						  variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assign_struct_name_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assign_struct_name_";

			Variable_listen_property_assign_struct_name_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_struct_name_;
			}

			virtual ~Variable_listen_property_assign_struct_name_() override = default;

			Variable_listen_property_assign_struct_name_(
				RecognizerTemplate* recognizertemplate_,
				const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assign_struct_name_;
			}

			Variable_listen_property_assign_struct_name_&
			operator=(const Variable_listen_property_assign_struct_name_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assignment_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assignment_";

			Variable_listen_property_assignment_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assignment_;
			}

			virtual ~Variable_listen_property_assignment_() override = default;

			Variable_listen_property_assignment_(RecognizerTemplate* recognizertemplate_,
												 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assignment_;
			}

			Variable_listen_property_assignment_&
			operator=(const Variable_listen_property_assignment_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_assignment_impl_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_assignment_impl_";

			Variable_listen_property_assignment_impl_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assignment_impl_;
			}

			virtual ~Variable_listen_property_assignment_impl_() override = default;

			Variable_listen_property_assignment_impl_(RecognizerTemplate* recognizertemplate_,
													  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_assignment_impl_;
			}

			Variable_listen_property_assignment_impl_&
			operator=(const Variable_listen_property_assignment_impl_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_entry_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_entry_";

			Variable_listen_property_entry_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_entry_;
			}

			virtual ~Variable_listen_property_entry_() override = default;

			Variable_listen_property_entry_(RecognizerTemplate* recognizertemplate_,
											const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_entry_;
			}

			Variable_listen_property_entry_&
			operator=(const Variable_listen_property_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_property_exit_ : public VariableScopes
		{
			static constexpr auto name = "listen_property_exit_";

			Variable_listen_property_exit_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_exit_;
			}

			virtual ~Variable_listen_property_exit_() override = default;

			Variable_listen_property_exit_(RecognizerTemplate* recognizertemplate_,
										   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_property_exit_;
			}

			Variable_listen_property_exit_&
			operator=(const Variable_listen_property_exit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_struct_entry_ : public VariableScopes
		{
			static constexpr auto name = "listen_struct_entry_";

			Variable_listen_struct_entry_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_struct_entry_;
			}

			virtual ~Variable_listen_struct_entry_() override = default;

			Variable_listen_struct_entry_(RecognizerTemplate* recognizertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_struct_entry_;
			}

			Variable_listen_struct_entry_& operator=(const Variable_listen_struct_entry_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_listen_struct_exit_ : public VariableScopes
		{
			static constexpr auto name = "listen_struct_exit_";

			Variable_listen_struct_exit_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_struct_exit_;
			}

			virtual ~Variable_listen_struct_exit_() override = default;

			Variable_listen_struct_exit_(RecognizerTemplate* recognizertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					listen_struct_exit_;
			}

			Variable_listen_struct_exit_& operator=(const Variable_listen_struct_exit_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_oopmodel_object_ : public VariableScopes
		{
			static constexpr auto name = "oopmodel_object_";

			Variable_oopmodel_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					oopmodel_object_;
			}

			virtual ~Variable_oopmodel_object_() override = default;

			Variable_oopmodel_object_(RecognizerTemplate* recognizertemplate_,
									  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					oopmodel_object_;
			}

			Variable_oopmodel_object_& operator=(const Variable_oopmodel_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_parent_continuation_ : public VariableScopes
		{
			static constexpr auto name = "optional_parent_continuation_";

			Variable_optional_parent_continuation_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					optional_parent_continuation_;
			}

			virtual ~Variable_optional_parent_continuation_() override = default;

			Variable_optional_parent_continuation_(RecognizerTemplate* recognizertemplate_,
												   const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					optional_parent_continuation_;
			}

			Variable_optional_parent_continuation_&
			operator=(const Variable_optional_parent_continuation_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_optional_parent_initializer_ : public VariableScopes
		{
			static constexpr auto name = "optional_parent_initializer_";

			Variable_optional_parent_initializer_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					optional_parent_initializer_;
			}

			virtual ~Variable_optional_parent_initializer_() override = default;

			Variable_optional_parent_initializer_(RecognizerTemplate* recognizertemplate_,
												  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					optional_parent_initializer_;
			}

			Variable_optional_parent_initializer_&
			operator=(const Variable_optional_parent_initializer_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_parent_continuation_ : public VariableScopes
		{
			static constexpr auto name = "parent_continuation_";

			Variable_parent_continuation_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					parent_continuation_;
			}

			virtual ~Variable_parent_continuation_() override = default;

			Variable_parent_continuation_(RecognizerTemplate* recognizertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					parent_continuation_;
			}

			Variable_parent_continuation_& operator=(const Variable_parent_continuation_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_parent_initializer_ : public VariableScopes
		{
			static constexpr auto name = "parent_initializer_";

			Variable_parent_initializer_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					parent_initializer_;
			}

			virtual ~Variable_parent_initializer_() override = default;

			Variable_parent_initializer_(RecognizerTemplate* recognizertemplate_,
										 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					parent_initializer_;
			}

			Variable_parent_initializer_& operator=(const Variable_parent_initializer_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_property_assignment_conditional_ : public VariableScopes
		{
			static constexpr auto name = "property_assignment_conditional_";

			Variable_property_assignment_conditional_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					property_assignment_conditional_;
			}

			virtual ~Variable_property_assignment_conditional_() override = default;

			Variable_property_assignment_conditional_(RecognizerTemplate* recognizertemplate_,
													  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					property_assignment_conditional_;
			}

			Variable_property_assignment_conditional_&
			operator=(const Variable_property_assignment_conditional_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_property_object_ : public VariableScopes
		{
			static constexpr auto name = "property_object_";

			Variable_property_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					property_object_;
			}

			virtual ~Variable_property_object_() override = default;

			Variable_property_object_(RecognizerTemplate* recognizertemplate_,
									  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					property_object_;
			}

			Variable_property_object_& operator=(const Variable_property_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_required_ast_node_ : public VariableScopes
		{
			static constexpr auto name = "required_ast_node_";

			Variable_required_ast_node_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					required_ast_node_;
			}

			virtual ~Variable_required_ast_node_() override = default;

			Variable_required_ast_node_(RecognizerTemplate* recognizertemplate_,
										const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					required_ast_node_;
			}

			Variable_required_ast_node_& operator=(const Variable_required_ast_node_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_required_production_rule_index_ : public VariableScopes
		{
			static constexpr auto name = "required_production_rule_index_";

			Variable_required_production_rule_index_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					required_production_rule_index_;
			}

			virtual ~Variable_required_production_rule_index_() override = default;

			Variable_required_production_rule_index_(RecognizerTemplate* recognizertemplate_,
													 const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					required_production_rule_index_;
			}

			Variable_required_production_rule_index_&
			operator=(const Variable_required_production_rule_index_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_angle_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_angle_bracket_";

			Variable_right_angle_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					right_angle_bracket_;
			}

			virtual ~Variable_right_angle_bracket_() override = default;

			Variable_right_angle_bracket_(RecognizerTemplate* recognizertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					right_angle_bracket_;
			}

			Variable_right_angle_bracket_& operator=(const Variable_right_angle_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_bracket_";

			Variable_right_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					right_bracket_;
			}

			virtual ~Variable_right_bracket_() override = default;

			Variable_right_bracket_(RecognizerTemplate* recognizertemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					right_bracket_;
			}

			Variable_right_bracket_& operator=(const Variable_right_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_right_curly_bracket_ : public VariableScopes
		{
			static constexpr auto name = "right_curly_bracket_";

			Variable_right_curly_bracket_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					right_curly_bracket_;
			}

			virtual ~Variable_right_curly_bracket_() override = default;

			Variable_right_curly_bracket_(RecognizerTemplate* recognizertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					right_curly_bracket_;
			}

			Variable_right_curly_bracket_& operator=(const Variable_right_curly_bracket_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_struct_object_ : public VariableScopes
		{
			static constexpr auto name = "struct_object_";

			Variable_struct_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					struct_object_;
			}

			virtual ~Variable_struct_object_() override = default;

			Variable_struct_object_(RecognizerTemplate* recognizertemplate_,
									const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					struct_object_;
			}

			Variable_struct_object_& operator=(const Variable_struct_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_tool_type_namespace_ : public VariableScopes
		{
			static constexpr auto name = "tool_type_namespace_";

			Variable_tool_type_namespace_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					tool_type_namespace_;
			}

			virtual ~Variable_tool_type_namespace_() override = default;

			Variable_tool_type_namespace_(RecognizerTemplate* recognizertemplate_,
										  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					tool_type_namespace_;
			}

			Variable_tool_type_namespace_& operator=(const Variable_tool_type_namespace_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

		struct Variable_type_object_ : public VariableScopes
		{
			static constexpr auto name = "type_object_";

			Variable_type_object_() : VariableScopes()
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					type_object_;
			}

			virtual ~Variable_type_object_() override = default;

			Variable_type_object_(RecognizerTemplate* recognizertemplate_,
								  const std::vector<VariableBase*>& variables)
				: VariableScopes(variables)
			{
				type = ::deamer::templates::oopsyntaxrecognizer::RecognizerTemplate::Type::
					type_object_;
			}

			Variable_type_object_& operator=(const Variable_type_object_& variable)
			{
				if (&variable == this)
				{
					return *this;
				}

				value = variable.value;
				isString = variable.isString;

				return *this;
			}
		};

	public:
		inline static std::vector<VariableBase*> variables_to_delete = std::vector<VariableBase*>();

	public:
		std::vector<VariableBase*> variables_;

	public:
		// Members that one can directly access.
		// e.g. RecognizerTemplate.member = "auto-generated";
		Variable_ast_node_* ast_node_ = new Variable_ast_node_();
		Variable_basetype_object_* basetype_object_ = new Variable_basetype_object_();
		Variable_class_object_* class_object_ = new Variable_class_object_();
		Variable_direct_access_extension_call_* direct_access_extension_call_ =
			new Variable_direct_access_extension_call_();
		Variable_enum_object_* enum_object_ = new Variable_enum_object_();
		Variable_extended_direct_access_specialization_name_*
			extended_direct_access_specialization_name_ =
				new Variable_extended_direct_access_specialization_name_();
		Variable_file_* file_ = new Variable_file_();
		Variable_function_argument_* function_argument_ = new Variable_function_argument_();
		Variable_function_object_* function_object_ = new Variable_function_object_();
		Variable_header_guard_* header_guard_ = new Variable_header_guard_();
		Variable_impl_extended_direct_access_* impl_extended_direct_access_ =
			new Variable_impl_extended_direct_access_();
		Variable_impl_extended_direct_access_specialization_*
			impl_extended_direct_access_specialization_ =
				new Variable_impl_extended_direct_access_specialization_();
		Variable_impl_simple_direct_access_* impl_simple_direct_access_ =
			new Variable_impl_simple_direct_access_();
		Variable_interface_object_* interface_object_ = new Variable_interface_object_();
		Variable_language_name_* language_name_ = new Variable_language_name_();
		Variable_left_angle_bracket_* left_angle_bracket_ = new Variable_left_angle_bracket_();
		Variable_left_bracket_* left_bracket_ = new Variable_left_bracket_();
		Variable_left_curly_bracket_* left_curly_bracket_ = new Variable_left_curly_bracket_();
		Variable_listen_basetype_entry_* listen_basetype_entry_ =
			new Variable_listen_basetype_entry_();
		Variable_listen_basetype_exit_* listen_basetype_exit_ =
			new Variable_listen_basetype_exit_();
		Variable_listen_class_entry_* listen_class_entry_ = new Variable_listen_class_entry_();
		Variable_listen_class_exit_* listen_class_exit_ = new Variable_listen_class_exit_();
		Variable_listen_enumeration_entry_* listen_enumeration_entry_ =
			new Variable_listen_enumeration_entry_();
		Variable_listen_enumeration_exit_* listen_enumeration_exit_ =
			new Variable_listen_enumeration_exit_();
		Variable_listen_function_entry_* listen_function_entry_ =
			new Variable_listen_function_entry_();
		Variable_listen_function_exit_* listen_function_exit_ =
			new Variable_listen_function_exit_();
		Variable_listen_functionargument_entry_* listen_functionargument_entry_ =
			new Variable_listen_functionargument_entry_();
		Variable_listen_functionargument_exit_* listen_functionargument_exit_ =
			new Variable_listen_functionargument_exit_();
		Variable_listen_interface_entry_* listen_interface_entry_ =
			new Variable_listen_interface_entry_();
		Variable_listen_interface_exit_* listen_interface_exit_ =
			new Variable_listen_interface_exit_();
		Variable_listen_property_assign_any_name_* listen_property_assign_any_name_ =
			new Variable_listen_property_assign_any_name_();
		Variable_listen_property_assign_basetype_type_* listen_property_assign_basetype_type_ =
			new Variable_listen_property_assign_basetype_type_();
		Variable_listen_property_assign_class_name_* listen_property_assign_class_name_ =
			new Variable_listen_property_assign_class_name_();
		Variable_listen_property_assign_enum_member_* listen_property_assign_enum_member_ =
			new Variable_listen_property_assign_enum_member_();
		Variable_listen_property_assign_enum_name_* listen_property_assign_enum_name_ =
			new Variable_listen_property_assign_enum_name_();
		Variable_listen_property_assign_function_argument_name_*
			listen_property_assign_function_argument_name_ =
				new Variable_listen_property_assign_function_argument_name_();
		Variable_listen_property_assign_function_argument_type_*
			listen_property_assign_function_argument_type_ =
				new Variable_listen_property_assign_function_argument_type_();
		Variable_listen_property_assign_function_name_* listen_property_assign_function_name_ =
			new Variable_listen_property_assign_function_name_();
		Variable_listen_property_assign_function_returntype_*
			listen_property_assign_function_returntype_ =
				new Variable_listen_property_assign_function_returntype_();
		Variable_listen_property_assign_interface_name_* listen_property_assign_interface_name_ =
			new Variable_listen_property_assign_interface_name_();
		Variable_listen_property_assign_property_name_* listen_property_assign_property_name_ =
			new Variable_listen_property_assign_property_name_();
		Variable_listen_property_assign_property_type_* listen_property_assign_property_type_ =
			new Variable_listen_property_assign_property_type_();
		Variable_listen_property_assign_specific_production_rule_action_*
			listen_property_assign_specific_production_rule_action_ =
				new Variable_listen_property_assign_specific_production_rule_action_();
		Variable_listen_property_assign_specific_production_rule_action_logic_*
			listen_property_assign_specific_production_rule_action_logic_ =
				new Variable_listen_property_assign_specific_production_rule_action_logic_();
		Variable_listen_property_assign_struct_name_* listen_property_assign_struct_name_ =
			new Variable_listen_property_assign_struct_name_();
		Variable_listen_property_assignment_* listen_property_assignment_ =
			new Variable_listen_property_assignment_();
		Variable_listen_property_assignment_impl_* listen_property_assignment_impl_ =
			new Variable_listen_property_assignment_impl_();
		Variable_listen_property_entry_* listen_property_entry_ =
			new Variable_listen_property_entry_();
		Variable_listen_property_exit_* listen_property_exit_ =
			new Variable_listen_property_exit_();
		Variable_listen_struct_entry_* listen_struct_entry_ = new Variable_listen_struct_entry_();
		Variable_listen_struct_exit_* listen_struct_exit_ = new Variable_listen_struct_exit_();
		Variable_oopmodel_object_* oopmodel_object_ = new Variable_oopmodel_object_();
		Variable_optional_parent_continuation_* optional_parent_continuation_ =
			new Variable_optional_parent_continuation_();
		Variable_optional_parent_initializer_* optional_parent_initializer_ =
			new Variable_optional_parent_initializer_();
		Variable_parent_continuation_* parent_continuation_ = new Variable_parent_continuation_();
		Variable_parent_initializer_* parent_initializer_ = new Variable_parent_initializer_();
		Variable_property_assignment_conditional_* property_assignment_conditional_ =
			new Variable_property_assignment_conditional_();
		Variable_property_object_* property_object_ = new Variable_property_object_();
		Variable_required_ast_node_* required_ast_node_ = new Variable_required_ast_node_();
		Variable_required_production_rule_index_* required_production_rule_index_ =
			new Variable_required_production_rule_index_();
		Variable_right_angle_bracket_* right_angle_bracket_ = new Variable_right_angle_bracket_();
		Variable_right_bracket_* right_bracket_ = new Variable_right_bracket_();
		Variable_right_curly_bracket_* right_curly_bracket_ = new Variable_right_curly_bracket_();
		Variable_struct_object_* struct_object_ = new Variable_struct_object_();
		Variable_tool_type_namespace_* tool_type_namespace_ = new Variable_tool_type_namespace_();
		Variable_type_object_* type_object_ = new Variable_type_object_();

	public:
		RecognizerTemplate()
		{
			*ast_node_ = Variable_ast_node_(this, std::vector<VariableBase*>({}));
			*basetype_object_ = Variable_basetype_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("BaseTypeObject")}));
			*class_object_ = Variable_class_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("ClassObject")}));
			*direct_access_extension_call_ = Variable_direct_access_extension_call_(
				this,
				std::vector<VariableBase*>({GenerateVariable(impl_simple_direct_access_->This())}));
			*enum_object_ = Variable_enum_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("EnumObject")}));
			*extended_direct_access_specialization_name_ =
				Variable_extended_direct_access_specialization_name_(
					this, std::vector<VariableBase*>({}));
			*file_ = Variable_file_(this, std::vector<VariableBase*>({}));
			*function_argument_ = Variable_function_argument_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("FunctionArgument")}));
			*function_object_ = Variable_function_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("FunctionObject")}));
			*header_guard_ = Variable_header_guard_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable(language_name_->This()),
					 GenerateVariable("_AST_LISTENER_TOOL_OOPSYNTAXRECOGNIZER_RECOGNIZER_H")}));
			*impl_extended_direct_access_ = Variable_impl_extended_direct_access_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("::"), GenerateVariable(language_name_->This()),
						   GenerateVariable("::ast::reference::Access(node)"),
						   GenerateVariable(
							   impl_extended_direct_access_specialization_->Variable_Field()),
						   GenerateVariable("."), GenerateVariable("GetContent()[0]->GetText()")}));
			*impl_extended_direct_access_specialization_ =
				Variable_impl_extended_direct_access_specialization_(
					this,
					std::vector<VariableBase*>(
						{GenerateVariable("."),
						 GenerateVariable(extended_direct_access_specialization_name_->This()),
						 GenerateVariable("()")}));
			*impl_simple_direct_access_ = Variable_impl_simple_direct_access_(
				this, std::vector<VariableBase*>({GenerateVariable("node->GetText()")}));
			*interface_object_ = Variable_interface_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("InterfaceObject")}));
			*language_name_ = Variable_language_name_(this, std::vector<VariableBase*>({}));
			*left_angle_bracket_ = Variable_left_angle_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable("<")}));
			*left_bracket_ =
				Variable_left_bracket_(this, std::vector<VariableBase*>({GenerateVariable("{")}));
			*left_curly_bracket_ = Variable_left_curly_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable("(")}));
			*listen_basetype_entry_ = Variable_listen_basetype_entry_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenEntry(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tBaseTypeFlavor++;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(FlavorType::BaseType);\n\t\t\tcurrentBaseTypeObject = new "),
					 GenerateVariable(basetype_object_->This()),
					 GenerateVariable("();\n\t\t\tcreatedBaseTypes"), GenerateVariable("."),
					 GenerateVariable("push_back(currentBaseTypeObject);\n\t\t"),
					 GenerateVariable("}")}));
			*listen_basetype_exit_ = Variable_listen_basetype_exit_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenExit(const "),
					 GenerateVariable(language_name_->This()),
					 GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tBaseTypeFlavor--;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "pop_back();\n\t\t\t\n\t\t\tif (ClassFlavor > 0 && currentClassObject != "
						 "nullptr && GetTopOfFlavorStack() == FlavorType::Class)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentClassObject->AddBaseType("
									  "currentBaseTypeObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 "\n\t\t\telse if (StructFlavor > 0 && currentStructObject != nullptr && "
						 "GetTopOfFlavorStack() == FlavorType::Struct)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentStructObject->AddBaseType("
									  "currentBaseTypeObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 "\n\t\t\telse if (InterfaceFlavor > 0 && currentInterfaceObject != "
						 "nullptr && GetTopOfFlavorStack() == FlavorType::Interface)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentInterfaceObject->AddBaseType("
									  "currentBaseTypeObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t\tcurrentBaseTypeObject = nullptr;\n\t\t"),
					 GenerateVariable("}")}));
			*listen_class_entry_ = Variable_listen_class_entry_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\n\t\tvoid ListenEntry(const "),
						   GenerateVariable(language_name_->This()),
						   GenerateVariable("::ast::node::"), GenerateVariable(ast_node_->This()),
						   GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
						   GenerateVariable("\n\t\t\tClassFlavor++;\n\t\t\tFlavorStack"),
						   GenerateVariable("."),
						   GenerateVariable(
							   "push_back(FlavorType::Class);\n\t\t\tcurrentClassObject = new "),
						   GenerateVariable(class_object_->This()),
						   GenerateVariable("();\n\t\t\tcreatedTypes"), GenerateVariable("."),
						   GenerateVariable("push_back(currentClassObject);\n\t\t"),
						   GenerateVariable("}")}));
			*listen_class_exit_ = Variable_listen_class_exit_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenExit(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tClassFlavor--;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable("pop_back();\n\t\t\tcurrentClassObject = nullptr;\n\t\t"),
					 GenerateVariable("}")}));
			*listen_enumeration_entry_ = Variable_listen_enumeration_entry_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenEntry(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tEnumFlavor++;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(FlavorType::Enum);\n\t\t\tcurrentEnumObject =\n\t\t\t\tnew "
						 "::deamer::external::cpp::tool::oopsyntaxrecognizer::EnumObject();"
						 "\n\t\t\tcreatedTypes"),
					 GenerateVariable("."), GenerateVariable("push_back(currentEnumObject);\n\t\t"),
					 GenerateVariable("}")}));
			*listen_enumeration_exit_ = Variable_listen_enumeration_exit_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenExit(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tEnumFlavor--;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable("pop_back();\n\t\t\tcurrentEnumObject = nullptr;\n\t\t"),
					 GenerateVariable("}")}));
			*listen_function_entry_ = Variable_listen_function_entry_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenEntry(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tFunctionFlavor++;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(FlavorType::Function);\n\t\t\tcurrentFunctionObject = new "),
					 GenerateVariable(function_object_->This()),
					 GenerateVariable("();\n\t\t\tcreatedFunctions"), GenerateVariable("."),
					 GenerateVariable("push_back(currentFunctionObject);\n\t\t"),
					 GenerateVariable("}")}));
			*listen_function_exit_ = Variable_listen_function_exit_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenExit(const "),
					 GenerateVariable(language_name_->This()),
					 GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tif (ClassFlavor > 0) // We are in some Class => It "
									  "is a member function\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentClassObject->AddFunction("
									  "currentFunctionObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse if (StructFlavor > 0) // We are in some Struct "
									  "=> It is a member function\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentStructObject->AddFunction("
									  "currentFunctionObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse if (EnumFlavor > 0) // We are in a enumeration "
									  "=> Something went wrong\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse // It is a global function\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tglobalFunctions"),
					 GenerateVariable("."),
					 GenerateVariable("push_back(currentFunctionObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t\tFunctionFlavor--;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable("pop_back();\n\t\t\tcurrentFunctionObject = nullptr;\n\t\t"),
					 GenerateVariable("}")}));
			*listen_functionargument_entry_ = Variable_listen_functionargument_entry_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\n\t\tvoid ListenEntry(const "),
						   GenerateVariable(language_name_->This()),
						   GenerateVariable("::ast::node::"), GenerateVariable(ast_node_->This()),
						   GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
						   GenerateVariable("\n\t\t\tFunctionArgumentFlavor++;\n\t\t\tFlavorStack"),
						   GenerateVariable("."),
						   GenerateVariable("push_back(FlavorType::FunctionArgument);"
											"\n\t\t\tcurrentFunctionArgumentObject = new "),
						   GenerateVariable(function_argument_->This()),
						   GenerateVariable("();\n\t\t\tcreatedFunctionsArguments"),
						   GenerateVariable("."),
						   GenerateVariable("push_back(currentFunctionArgumentObject);\n\t\t"),
						   GenerateVariable("}")}));
			*listen_functionargument_exit_ = Variable_listen_functionargument_exit_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenExit(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tif (FunctionFlavor > 0 && currentFunctionObject != "
									  "nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentFunctionObject->AddArgument("
									  "currentFunctionArgumentObject);\n\t\t\t"),
					 GenerateVariable("}"), GenerateVariable("\n\t\t\telse\n\t\t\t"),
					 GenerateVariable("{"), GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t\tFunctionArgumentFlavor--;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "pop_back();\n\t\t\tcurrentFunctionArgumentObject = nullptr;\n\t\t"),
					 GenerateVariable("}")}));
			*listen_interface_entry_ = Variable_listen_interface_entry_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenEntry(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tInterfaceFlavor++;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(FlavorType::Interface);\n\t\t\tcurrentInterfaceObject = new "),
					 GenerateVariable(interface_object_->This()),
					 GenerateVariable("();\n\t\t\tcreatedTypes"), GenerateVariable("."),
					 GenerateVariable("push_back(currentInterfaceObject);\n\t\t"),
					 GenerateVariable("}")}));
			*listen_interface_exit_ = Variable_listen_interface_exit_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenExit(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tInterfaceFlavor--;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable("pop_back();\n\t\t\tcurrentInterfaceObject = nullptr;\n\t\t"),
					 GenerateVariable("}")}));
			*listen_property_assign_any_name_ = Variable_listen_property_assign_any_name_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\t\t\tswitch(GetTopOfFlavorStack())\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tcase FlavorType::FunctionArgument: "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tif (FunctionArgumentFlavor > 0 && "
									  "currentFunctionArgumentObject != nullptr)\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\tcurrentFunctionArgumentObject->SetName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\telse\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\t// Error\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\tbreak;\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\tcase FlavorType::Function: "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tif (FunctionFlavor > 0 && currentFunctionObject "
									  "!= nullptr)\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\tcurrentFunctionObject->SetName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\telse\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\t// Error\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\tbreak;\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\tcase FlavorType::Class: "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tif (ClassFlavor > 0 && currentClassObject != "
									  "nullptr)\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\tcurrentClassObject->SetTypeName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\telse\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\t// Error\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\tbreak;\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\tcase FlavorType::Struct: "),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tif (StructFlavor > 0 && currentStructObject != "
									  "nullptr)\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\tcurrentStructObject->SetTypeName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\telse\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\t// Error\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\tbreak;\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\tcase FlavorType::Enum: "),
					 GenerateVariable("{"),
					 GenerateVariable(
						 "\n\t\t\t\tif (EnumFlavor > 0 && currentEnumObject != nullptr)\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\tcurrentEnumObject->SetTypeName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\telse\n\t\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t\t// Error\n\t\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t\tbreak;\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\t"),
					 GenerateVariable("}")}));
			*listen_property_assign_basetype_type_ = Variable_listen_property_assign_basetype_type_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\t\t\tif (BaseTypeFlavor > 0 && GetTopOfFlavorStack() == "
									  "FlavorType::BaseType &&\n\t\t\t\tcurrentBaseTypeObject != "
									  "nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentBaseTypeObject->SetType(GetType("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable("));\n\t\t\t"), GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_class_name_ = Variable_listen_property_assign_class_name_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable(
						 "\t\t\tif (ClassFlavor > 0 && GetTopOfFlavorStack() == FlavorType::Class "
						 "&&\n\t\t\t\tcurrentClassObject != nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentClassObject->SetTypeName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t"), GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_enum_member_ = Variable_listen_property_assign_enum_member_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable(
						 "\t\t\tif (EnumFlavor > 0 && GetTopOfFlavorStack() == FlavorType::Enum "
						 "&&\n\t\t\t\tcurrentEnumObject != nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentEnumObject->AddMember("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t"), GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_enum_name_ = Variable_listen_property_assign_enum_name_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable(
						 "\t\t\tif (EnumFlavor > 0 && GetTopOfFlavorStack() == FlavorType::Enum "
						 "&&\n\t\t\t\tcurrentEnumObject != nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentEnumObject->SetTypeName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t"), GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_function_argument_name_ =
				Variable_listen_property_assign_function_argument_name_(
					this,
					std::vector<VariableBase*>(
						{GenerateVariable(
							 "\t\t\tif (FunctionArgumentFlavor > 0 && GetTopOfFlavorStack() == "
							 "FlavorType::FunctionArgument "
							 "&&\n\t\t\t\tcurrentFunctionArgumentObject != nullptr)\n\t\t\t"),
						 GenerateVariable("{"),
						 GenerateVariable("\n\t\t\t\tcurrentFunctionArgumentObject->SetName("),
						 GenerateVariable(direct_access_extension_call_->This()),
						 GenerateVariable(");\n\t\t\t"), GenerateVariable("}"),
						 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
						 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_function_argument_type_ =
				Variable_listen_property_assign_function_argument_type_(
					this,
					std::vector<VariableBase*>(
						{GenerateVariable(
							 "\t\t\tif (FunctionArgumentFlavor > 0 && GetTopOfFlavorStack() == "
							 "FlavorType::FunctionArgument "
							 "&&\n\t\t\t\tcurrentFunctionArgumentObject != nullptr)\n\t\t\t"),
						 GenerateVariable("{"),
						 GenerateVariable(
							 "\n\t\t\t\tcurrentFunctionArgumentObject->SetType(GetType("),
						 GenerateVariable(direct_access_extension_call_->This()),
						 GenerateVariable("));\n\t\t\t"), GenerateVariable("}"),
						 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
						 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_function_name_ = Variable_listen_property_assign_function_name_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\t\t\tif (FunctionFlavor > 0 && GetTopOfFlavorStack() == "
									  "FlavorType::Function &&\n\t\t\t\tcurrentFunctionObject != "
									  "nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentFunctionObject->SetName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t"), GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_function_returntype_ =
				Variable_listen_property_assign_function_returntype_(
					this,
					std::vector<VariableBase*>(
						{GenerateVariable("\t\t\tif (FunctionFlavor > 0 && GetTopOfFlavorStack() "
										  "== FlavorType::Function "
										  "&&\n\t\t\t\tcurrentFunctionObject != nullptr)\n\t\t\t"),
						 GenerateVariable("{"),
						 GenerateVariable(
							 "\n\t\t\t\t// Assumes the type is predefined\n\t\t\t\t// Can be "
							 "updated to insert temporary forward declaration\n\t\t\t\t// This "
							 "requires a final check which replaces forward "
							 "declarations\n\t\t\t\tcurrentFunctionObject->SetReturnType(GetType("),
						 GenerateVariable(direct_access_extension_call_->This()),
						 GenerateVariable("));\n\t\t\t"), GenerateVariable("}"),
						 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
						 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_interface_name_ =
				Variable_listen_property_assign_interface_name_(
					this,
					std::vector<VariableBase*>(
						{GenerateVariable("\t\t\tif (InterfaceFlavor > 0 && GetTopOfFlavorStack() "
										  "== FlavorType::Interface "
										  "&&\n\t\t\t\tcurrentInterfaceObject != nullptr)\n\t\t\t"),
						 GenerateVariable("{"),
						 GenerateVariable("\n\t\t\t\tcurrentInterfaceObject->SetTypeName("),
						 GenerateVariable(direct_access_extension_call_->This()),
						 GenerateVariable(");\n\t\t\t"), GenerateVariable("}"),
						 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
						 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_property_name_ = Variable_listen_property_assign_property_name_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\t\t\tif (PropertyFlavor > 0 && GetTopOfFlavorStack() == "
									  "FlavorType::Property &&\n\t\t\t\tcurrentPropertyObject != "
									  "nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentPropertyObject->SetName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t"), GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_property_type_ = Variable_listen_property_assign_property_type_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\t\t\tif (PropertyFlavor > 0 && GetTopOfFlavorStack() == "
									  "FlavorType::Property &&\n\t\t\t\tcurrentPropertyObject != "
									  "nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentPropertyObject->SetType(GetType("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable("));\n\t\t\t"), GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assign_specific_production_rule_action_ =
				Variable_listen_property_assign_specific_production_rule_action_(
					this, std::vector<VariableBase*>(
							  {GenerateVariable(optional_parent_initializer_->This()),
							   GenerateVariable(optional_parent_continuation_->This()),
							   GenerateVariable("\n\t\t\tif ("),
							   GenerateVariable(property_assignment_conditional_->This()),
							   GenerateVariable(")\n\t\t\t"), GenerateVariable("{"),
							   GenerateVariable(
								   "\n\t\t\t\t// If the conditional was True, checks if the next "
								   "conditions are correct\n\t\t\t\t// And executes the logic"),
							   GenerateVariable("."), GenerateVariable("\n\t\t\t\t"),
							   GenerateVariable(
								   listen_property_assign_specific_production_rule_action_logic_
									   ->Variable_Field()),
							   GenerateVariable("\n\t\t\t"), GenerateVariable("}"),
							   GenerateVariable("\n")}));
			*listen_property_assign_specific_production_rule_action_logic_ =
				Variable_listen_property_assign_specific_production_rule_action_logic_(
					this, std::vector<VariableBase*>({}));
			*listen_property_assign_struct_name_ = Variable_listen_property_assign_struct_name_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable(
						 "\t\t\tif (StructFlavor > 0 && GetTopOfFlavorStack() == "
						 "FlavorType::Struct &&\n\t\t\t\tcurrentStructObject != nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentStructObject->SetTypeName("),
					 GenerateVariable(direct_access_extension_call_->This()),
					 GenerateVariable(");\n\t\t\t"), GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Error\n\t\t\t"), GenerateVariable("}")}));
			*listen_property_assignment_ = Variable_listen_property_assignment_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenEntry(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n"),
					 GenerateVariable(listen_property_assignment_impl_->Variable_Field()),
					 GenerateVariable("\n\t\t"), GenerateVariable("}"), GenerateVariable("\n")}));
			*listen_property_assignment_impl_ =
				Variable_listen_property_assignment_impl_(this, std::vector<VariableBase*>({}));
			*listen_property_entry_ = Variable_listen_property_entry_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenEntry(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tPropertyFlavor++;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "push_back(FlavorType::Property);\n\t\t\tcurrentPropertyObject = new "),
					 GenerateVariable(property_object_->This()), GenerateVariable("();\n\t\t"),
					 GenerateVariable("}")}));
			*listen_property_exit_ = Variable_listen_property_exit_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenExit(const "),
					 GenerateVariable(language_name_->This()),
					 GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tPropertyFlavor--;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable(
						 "pop_back();\n\n\t\t\tif (ClassFlavor > 0 && FunctionFlavor > 0)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Add to function\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 "\n\t\t\telse if (StructFlavor > 0 && FunctionFlavor > 0)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\t// Add to function\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 "\n\t\t\telse if (ClassFlavor > 0 && GetTopOfFlavorStack() == "
						 "FlavorType::Class && currentClassObject != nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentClassObject->AddProperty("
									  "currentPropertyObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable(
						 "\n\t\t\telse if (StructFlavor > 0 && GetTopOfFlavorStack() == "
						 "FlavorType::Struct && currentStructObject != nullptr)\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tcurrentStructObject->AddProperty("
									  "currentPropertyObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\t\t\telse\n\t\t\t"),
					 GenerateVariable("{"),
					 GenerateVariable("\n\t\t\t\tglobalProperties"),
					 GenerateVariable("."),
					 GenerateVariable("push_back(currentPropertyObject);\n\t\t\t"),
					 GenerateVariable("}"),
					 GenerateVariable("\n\n\t\t\tcurrentPropertyObject = nullptr;\n\t\t"),
					 GenerateVariable("}")}));
			*listen_struct_entry_ = Variable_listen_struct_entry_(
				this, std::vector<VariableBase*>(
						  {GenerateVariable("\n\t\tvoid ListenEntry(const "),
						   GenerateVariable(language_name_->This()),
						   GenerateVariable("::ast::node::"), GenerateVariable(ast_node_->This()),
						   GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
						   GenerateVariable("\n\t\t\tStructFlavor++;\n\t\t\tFlavorStack"),
						   GenerateVariable("."),
						   GenerateVariable(
							   "push_back(FlavorType::Struct);\n\t\t\tcurrentStructObject = new "),
						   GenerateVariable(struct_object_->This()),
						   GenerateVariable("();\n\t\t\tcreatedTypes"), GenerateVariable("."),
						   GenerateVariable("push_back(currentStructObject);\n\t\t"),
						   GenerateVariable("}")}));
			*listen_struct_exit_ = Variable_listen_struct_exit_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("\n\t\tvoid ListenExit(const "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"),
					 GenerateVariable(ast_node_->This()),
					 GenerateVariable("* node) override\n\t\t"), GenerateVariable("{"),
					 GenerateVariable("\n\t\t\tStructFlavor--;\n\t\t\tFlavorStack"),
					 GenerateVariable("."),
					 GenerateVariable("pop_back();\n\t\t\tcurrentStructObject = nullptr;\n\t\t"),
					 GenerateVariable("}")}));
			*oopmodel_object_ = Variable_oopmodel_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("OopModel")}));
			*optional_parent_continuation_ = Variable_optional_parent_continuation_(
				this, std::vector<VariableBase*>({GenerateVariable(parent_continuation_->This())}));
			*optional_parent_initializer_ = Variable_optional_parent_initializer_(
				this, std::vector<VariableBase*>({GenerateVariable(parent_initializer_->This())}));
			*parent_continuation_ = Variable_parent_continuation_(
				this,
				std::vector<VariableBase*>({GenerateVariable("parent = parent->GetParent();")}));
			*parent_initializer_ = Variable_parent_initializer_(
				this, std::vector<VariableBase*>({GenerateVariable(
						  "\t\t\t// This is extended each time a new specialization\n\t\t\tconst "
						  "::deamer::external::cpp::ast::Node* parent = node;\n")}));
			*property_assignment_conditional_ = Variable_property_assignment_conditional_(
				this,
				std::vector<VariableBase*>(
					{GenerateVariable("(parent != nullptr) && (parent->GetType() == "),
					 GenerateVariable(language_name_->This()), GenerateVariable("::ast::Type::"),
					 GenerateVariable(required_ast_node_->This()),
					 GenerateVariable(") && (parent->GetMatchedProductionRule()"),
					 GenerateVariable("."), GenerateVariable("id == "),
					 GenerateVariable(required_production_rule_index_->This()),
					 GenerateVariable(")")}));
			*property_object_ = Variable_property_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("PropertyObject")}));
			*required_ast_node_ = Variable_required_ast_node_(this, std::vector<VariableBase*>({}));
			*required_production_rule_index_ =
				Variable_required_production_rule_index_(this, std::vector<VariableBase*>({}));
			*right_angle_bracket_ = Variable_right_angle_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable(">")}));
			*right_bracket_ =
				Variable_right_bracket_(this, std::vector<VariableBase*>({GenerateVariable("}")}));
			*right_curly_bracket_ = Variable_right_curly_bracket_(
				this, std::vector<VariableBase*>({GenerateVariable(")")}));
			*struct_object_ = Variable_struct_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("StructObject")}));
			*tool_type_namespace_ = Variable_tool_type_namespace_(
				this, std::vector<VariableBase*>({GenerateVariable(
						  "::deamer::external::cpp::tool::oopsyntaxrecognizer::")}));
			*type_object_ = Variable_type_object_(
				this, std::vector<VariableBase*>({GenerateVariable(tool_type_namespace_->This()),
												  GenerateVariable("Type")}));

			variables_.emplace_back(ast_node_);
			variables_.emplace_back(basetype_object_);
			variables_.emplace_back(class_object_);
			variables_.emplace_back(direct_access_extension_call_);
			variables_.emplace_back(enum_object_);
			variables_.emplace_back(extended_direct_access_specialization_name_);
			variables_.emplace_back(file_);
			variables_.emplace_back(function_argument_);
			variables_.emplace_back(function_object_);
			variables_.emplace_back(header_guard_);
			variables_.emplace_back(impl_extended_direct_access_);
			variables_.emplace_back(impl_extended_direct_access_specialization_);
			variables_.emplace_back(impl_simple_direct_access_);
			variables_.emplace_back(interface_object_);
			variables_.emplace_back(language_name_);
			variables_.emplace_back(left_angle_bracket_);
			variables_.emplace_back(left_bracket_);
			variables_.emplace_back(left_curly_bracket_);
			variables_.emplace_back(listen_basetype_entry_);
			variables_.emplace_back(listen_basetype_exit_);
			variables_.emplace_back(listen_class_entry_);
			variables_.emplace_back(listen_class_exit_);
			variables_.emplace_back(listen_enumeration_entry_);
			variables_.emplace_back(listen_enumeration_exit_);
			variables_.emplace_back(listen_function_entry_);
			variables_.emplace_back(listen_function_exit_);
			variables_.emplace_back(listen_functionargument_entry_);
			variables_.emplace_back(listen_functionargument_exit_);
			variables_.emplace_back(listen_interface_entry_);
			variables_.emplace_back(listen_interface_exit_);
			variables_.emplace_back(listen_property_assign_any_name_);
			variables_.emplace_back(listen_property_assign_basetype_type_);
			variables_.emplace_back(listen_property_assign_class_name_);
			variables_.emplace_back(listen_property_assign_enum_member_);
			variables_.emplace_back(listen_property_assign_enum_name_);
			variables_.emplace_back(listen_property_assign_function_argument_name_);
			variables_.emplace_back(listen_property_assign_function_argument_type_);
			variables_.emplace_back(listen_property_assign_function_name_);
			variables_.emplace_back(listen_property_assign_function_returntype_);
			variables_.emplace_back(listen_property_assign_interface_name_);
			variables_.emplace_back(listen_property_assign_property_name_);
			variables_.emplace_back(listen_property_assign_property_type_);
			variables_.emplace_back(listen_property_assign_specific_production_rule_action_);
			variables_.emplace_back(listen_property_assign_specific_production_rule_action_logic_);
			variables_.emplace_back(listen_property_assign_struct_name_);
			variables_.emplace_back(listen_property_assignment_);
			variables_.emplace_back(listen_property_assignment_impl_);
			variables_.emplace_back(listen_property_entry_);
			variables_.emplace_back(listen_property_exit_);
			variables_.emplace_back(listen_struct_entry_);
			variables_.emplace_back(listen_struct_exit_);
			variables_.emplace_back(oopmodel_object_);
			variables_.emplace_back(optional_parent_continuation_);
			variables_.emplace_back(optional_parent_initializer_);
			variables_.emplace_back(parent_continuation_);
			variables_.emplace_back(parent_initializer_);
			variables_.emplace_back(property_assignment_conditional_);
			variables_.emplace_back(property_object_);
			variables_.emplace_back(required_ast_node_);
			variables_.emplace_back(required_production_rule_index_);
			variables_.emplace_back(right_angle_bracket_);
			variables_.emplace_back(right_bracket_);
			variables_.emplace_back(right_curly_bracket_);
			variables_.emplace_back(struct_object_);
			variables_.emplace_back(tool_type_namespace_);
			variables_.emplace_back(type_object_);
		}

		virtual ~RecognizerTemplate()
		{
			for (auto* variable : variables_to_delete)
			{
				delete variable;
			}

			variables_to_delete.clear();
		}

	public:
		// Default DST functions

		/*!	\fn GetOutput
		 *
		 *	\brief returns the output with the given the current state.
		 */
		std::string GetOutput()
		{
			return file_->Content()->GetValue();
		}

		/*!	\fn GetVariables
		 *
		 *	\brief Returns all top level variables known in this template.
		 */
		std::vector<VariableBase*> GetVariables()
		{
			return variables_;
		}

	public:
	};
}

#endif // DEAMER_TEMPLATES_OOPSYNTAXRECOGNIZER_RECOGNIZERTEMPLATE_h
