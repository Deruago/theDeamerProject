#ifndef DEAMER_TEMPLATES_BISON_PARSER_PARSERDEFINITIONTEMPLATE_h
#define DEAMER_TEMPLATES_BISON_PARSER_PARSERDEFINITIONTEMPLATE_h

#include <variant>
#include <vector>
#include <string>

namespace deamer::templates::bison::parser
{

	/*!	\class ParserDefinitionTemplate
	 *
	 *	\brief Generates code for "ParserDefinitionTemplate"
	 *
	 *	\details This is generated by DST.
	 *	For more information visit: https://github.com/Deruago/DeamerStringTemplate
	 */
	class ParserDefinitionTemplate
	{
	public:
		enum class Type
{
Unknown,
Scope,

// User defined types
extended_error_,
file_,
glr_setting_,
ignore_section_,
language_name_,
left_angle_bracket_,
left_bracket_,
left_curly_bracket_,
nonterminal_declaration_,
nonterminal_implementation_,
nonterminal_include_,
nonterminal_token_name_,
optional_comma_,
optional_extended_error_,
optional_glr_setting_,
optional_or_,
optional_parse_lac_,
optional_top_nonterminal_output_,
or_,
parse_lac_,
production_rule_,
production_rule_implementation_,
production_rule_index_,
production_rule_retrieved_tokens_,
production_rule_retrieved_tokens_impl_,
production_rule_type_,
right_angle_bracket_,
right_bracket_,
right_curly_bracket_,
terminal_declaration_,
terminal_include_,
token_index_,
token_name_,
top_nonterminal_output_,
transfer_nonterminal_,
transfer_terminal_,
union_declaration_,


};


		enum class ScopeType
{
Unknown,

// Default
Default_,
Upper_,
Lower_,

Snake_,
Slash_,
BackSlash_,
Colon_,
DoubleColon_,

Variable_Field_,
Variable_Field_Separator_,
Function_Field_,
Function_Field_Separator_,


};


		static constexpr const char* ConvertEnumToName(::deamer::templates::bison::parser::ParserDefinitionTemplate::Type enumerationValue)
{
	switch(enumerationValue)
	{
	case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::extended_error_:
{
	return "extended_error";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::file_:
{
	return "file";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::glr_setting_:
{
	return "glr_setting";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::ignore_section_:
{
	return "ignore_section";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::language_name_:
{
	return "language_name";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_angle_bracket_:
{
	return "left_angle_bracket";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_bracket_:
{
	return "left_bracket";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_curly_bracket_:
{
	return "left_curly_bracket";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_declaration_:
{
	return "nonterminal_declaration";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_implementation_:
{
	return "nonterminal_implementation";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_include_:
{
	return "nonterminal_include";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_token_name_:
{
	return "nonterminal_token_name";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_comma_:
{
	return "optional_comma";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_extended_error_:
{
	return "optional_extended_error";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_glr_setting_:
{
	return "optional_glr_setting";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_or_:
{
	return "optional_or";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_parse_lac_:
{
	return "optional_parse_lac";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_top_nonterminal_output_:
{
	return "optional_top_nonterminal_output";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::or_:
{
	return "or";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::parse_lac_:
{
	return "parse_lac";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_:
{
	return "production_rule";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_implementation_:
{
	return "production_rule_implementation";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_index_:
{
	return "production_rule_index";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_retrieved_tokens_:
{
	return "production_rule_retrieved_tokens";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_retrieved_tokens_impl_:
{
	return "production_rule_retrieved_tokens_impl";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_type_:
{
	return "production_rule_type";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_angle_bracket_:
{
	return "right_angle_bracket";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_bracket_:
{
	return "right_bracket";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_curly_bracket_:
{
	return "right_curly_bracket";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::terminal_declaration_:
{
	return "terminal_declaration";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::terminal_include_:
{
	return "terminal_include";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::token_index_:
{
	return "token_index";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::token_name_:
{
	return "token_name";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::top_nonterminal_output_:
{
	return "top_nonterminal_output";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::transfer_nonterminal_:
{
	return "transfer_nonterminal";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::transfer_terminal_:
{
	return "transfer_terminal";
}

case ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::union_declaration_:
{
	return "union_declaration";
}


	}

	return "";
}


		
	public:
		struct VariableBase
		{
			// The value is either a string
			// or a vector of variables.
			std::variant<std::string, std::vector<VariableBase*>> value;
			bool isString = true;

			::deamer::templates::bison::parser::ParserDefinitionTemplate::Type type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Unknown;

			VariableBase() : VariableBase(std::vector<VariableBase*>())
			{
			}

			virtual ~VariableBase() = default;

			VariableBase(const char* text)
			{
				isString = true;
				value = text;
			}

			VariableBase(const std::string& text)
			{
				isString = true;
				value = text;
			}

			VariableBase(std::vector<VariableBase*> variables)
			{
				isString = false;
				value = variables;
			}

			VariableBase* This()
			{
				return this;
			}

			virtual std::string GetValue()
			{
				if (isString)
				{
					return std::get<std::string>(value);
				}
				else
				{
					std::string output;
					auto& variables = std::get<std::vector<VariableBase*>>(value);
					for (auto* variable : variables)
					{
						output += variable->GetValue();
					}
					return output;
				}
			}

			std::string GetName()
			{
				return ConvertEnumToName(type);
			}

			VariableBase& operator=(const std::string& variable)
			{
				return Set(variable);
			}

			VariableBase& operator=(VariableBase* variable)
			{
				return Set(variable);
			}

			VariableBase& operator+=(VariableBase* variable)
			{
				return Add(variable);
			}

			VariableBase& operator+=(const std::string& variable)
			{
				return Add(variable);
			}

			VariableBase& Set(const std::string& variable)
			{
				value = variable;
				isString = true;

				return *this;
			}

			VariableBase& Set(VariableBase* variable)
			{
				if (variable == this)
				{
					return *this;
				}

				value = variable->value;
				isString = variable->isString;

				return *this;
			}

			VariableBase& Add(const std::string& variable)
			{
				if (isString)
				{
					auto& text = std::get<std::string>(value);
					text += variable;
					value = text;
				}
				else
				{
					auto& vector = std::get<std::vector<VariableBase*>>(value);
					vector.push_back(new VariableBase(variable));
					value = vector;
				}

				return *this;
			}

			VariableBase& Add(VariableBase* variable)
			{
				if (variable == this)
				{
					return *this;
				}

				if (isString)
				{
					// convert current -> variablebase
					// then create a vector.
					auto& currentValue = std::get<std::string>(value);
					auto* currentValueAsVariableBase = new VariableBase(currentValue);
					value = std::vector<VariableBase*>({ currentValueAsVariableBase, variable });

					isString = false;
				}
				else
				{
					auto& vector = std::get<std::vector<VariableBase*>>(value);
					vector.push_back(variable);
					value = vector;
				}

				return *this;
			}

			void Clear()
			{
				if (isString)
				{
					value = "";
				}
				else
				{
					value = std::vector<VariableBase*>();
				}
			}

			void* operator new(size_t size)
			{
				void* newVariable = ::operator new(size);
				variables_to_delete.emplace_back(static_cast<VariableBase*>(newVariable));

				return newVariable;
			}
		};

		static VariableBase* GenerateVariable(VariableBase* variable)
		{
			return variable;
		}

		
		static VariableBase* GenerateVariable(const std::string& variable)
		{
			return new VariableBase(variable);
		}

		struct VariableScope : public VariableBase
		{
			::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType scope_type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::Unknown;
			bool isReserved = false;

			VariableScope(::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType scope_type_, bool isReserved_ = false) : VariableBase(), scope_type(scope_type_), isReserved(isReserved_)
			{
				type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;
			}

			VariableScope(const char* text, ::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType scope_type_, bool isReserved_ = false) : VariableBase(text), scope_type(scope_type_), isReserved(isReserved_)
			{
				type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;
			}

			VariableScope(std::vector<VariableBase*> variable, ::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType scope_type_, bool isReserved_ = false) : VariableBase(variable), scope_type(scope_type_), isReserved(isReserved_)
			{
				type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;
			}
		};
		
		struct Variable_ReservedScope_Upper : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Upper(VariableBase* base_)
			: VariableScope(::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::Upper_, true),
			  base(base_)
			{
			}
			
			virtual std::string GetValue() override
			{
				std::string upperVariant;
				std::string currentValue = base->GetValue();

				for (const auto character : currentValue)
				{
					upperVariant += std::toupper(character);
				}

				return upperVariant;
			}
		};
		
		struct Variable_ReservedScope_Lower : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Lower(VariableBase* base_)
			: VariableScope(::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::Lower_, true),
			  base(base_)
			{
			}
			
			virtual std::string GetValue() override
			{
				std::string lowerVariant;
				std::string currentValue = base->GetValue();

				for (const auto character : currentValue)
				{
					lowerVariant += std::tolower(character);
				}

				return lowerVariant;
			}
		};
		
		struct Variable_ReservedScope_Snake : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Snake(VariableBase* base_)
			: VariableScope(::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::Snake_, true),
			  base(base_)
			{
			}
			
			virtual std::string GetValue() override
			{
				std::string snakeVariant;
				std::string currentValue = base->GetValue();
				
				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						snakeVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}
						
						snakeVariant += '_';
						lastWasNonAlpha = true;
					}
				}
				
				// If it contains text
				// remove the tail
				if (!snakeVariant.empty() && lastWasNonAlpha)
				{
					snakeVariant.pop_back();
				}

				return snakeVariant;
			}
		};
		
		struct Variable_ReservedScope_Slash : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_Slash(VariableBase* base_)
			: VariableScope(::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::Slash_, true),
			  base(base_)
			{
			}
			
			virtual std::string GetValue() override
			{
				std::string slashVariant;
				std::string currentValue = base->GetValue();
				
				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						slashVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}
						
						slashVariant += '/';
						lastWasNonAlpha = true;
					}
				}
				
				// If it contains text
				// remove the tail
				if (!slashVariant.empty() && lastWasNonAlpha)
				{
					slashVariant.pop_back();
				}

				return slashVariant;
			}
		};
		
		struct Variable_ReservedScope_DoubleColon : public VariableScope
		{
			VariableBase* base;
			Variable_ReservedScope_DoubleColon(VariableBase* base_)
			: VariableScope(::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::DoubleColon_, true),
			  base(base_)
			{
			}
			
			virtual std::string GetValue() override
			{
				std::string doubleColonVariant;
				std::string currentValue = base->GetValue();
				
				bool lastWasNonAlpha = true;
				for (const auto character : currentValue)
				{
					if (std::isalpha(character))
					{
						doubleColonVariant += character;
						lastWasNonAlpha = false;
					}
					else
					{
						if (lastWasNonAlpha)
						{
							continue;
						}
						
						doubleColonVariant += "::";
						lastWasNonAlpha = true;
					}
				}
				
				// If it contains text
				// remove the tail
				if (!doubleColonVariant.empty() && lastWasNonAlpha)
				{
					doubleColonVariant.pop_back();
					doubleColonVariant.pop_back();
				}

				return doubleColonVariant;
			}
		};

		struct VariableScopes : public VariableBase
		{
			// Default scopes
			VariableBase* default_ = new VariableScope(::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::Default_, true);
			VariableBase* upper_ = new Variable_ReservedScope_Upper(this);
			VariableBase* lower_ = new Variable_ReservedScope_Lower(this);
			
			VariableBase* snake_ = new Variable_ReservedScope_Snake(this);
			VariableBase* slash_ = new Variable_ReservedScope_Slash(this);
			VariableBase* double_colon_ = new Variable_ReservedScope_DoubleColon(this);
			
			VariableBase* variable_field_ = new VariableScope(::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::Variable_Field_, true);
			VariableBase* variable_field_separator_ = new VariableScope("\n", ::deamer::templates::bison::parser::ParserDefinitionTemplate::ScopeType::Variable_Field_Separator_, true);

			// Ctor
			VariableScopes() : VariableBase() {}

			VariableScopes(const char* text) : VariableBase(text) {}

			VariableScopes(const std::string& text) : VariableBase(text) {}

			VariableScopes(std::vector<VariableBase*> variables) : VariableBase(variables) {}

			// Dtor
			virtual ~VariableScopes() override = default;

			// Calls
			VariableBase* Default()
			{
				return default_;
			}
			VariableBase* Upper()
			{
				return upper_;
			}

			VariableBase* Lower()
			{
				return lower_;
			}

			VariableBase* Underscore()
			{
				return snake_;
			}

			VariableBase* Snake()
			{
				return snake_;
			}

			VariableBase* Slash()
			{
				return slash_;
			}

			VariableBase* DoubleColon()
			{
				return double_colon_;
			}

			VariableBase* Variable_Field()
			{
				return variable_field_;
			}

			VariableBase* Variable_Field_Separator()
			{
				return variable_field_separator_;
			}

			void ExpandVariableField()
			{
				// currentvalue + separator
				const auto currentValue = GetValue() + Variable_Field_Separator()->GetValue();
				*Variable_Field() += currentValue;
			}
		};

	public:
		
struct Variable_extended_error_ : public VariableScopes
{

static constexpr auto name = "extended_error_";



Variable_extended_error_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::extended_error_;
}

virtual ~Variable_extended_error_() override = default;

Variable_extended_error_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::extended_error_;

}



Variable_extended_error_& operator=(const Variable_extended_error_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_file_ : public VariableScopes
{

static constexpr auto name = "file_";

VariableBase* Content_ = GenerateVariable("");
VariableBase* Class_postfix_ = GenerateVariable("");
VariableBase* Extension_ = GenerateVariable("");
VariableBase* File_name_ = GenerateVariable("");
VariableBase* Namespace_ = GenerateVariable("");
VariableBase* Target_language_ = GenerateVariable("");


Variable_file_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::file_;
}

virtual ~Variable_file_() override = default;

Variable_file_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::file_;
*static_cast<VariableBase*>(Content_) = VariableBase(std::vector<VariableBase*>({ GenerateVariable(parserdefinitiontemplate_->optional_extended_error_->This()), GenerateVariable("\n"), GenerateVariable(parserdefinitiontemplate_->optional_parse_lac_->This()), GenerateVariable("\n"), GenerateVariable(parserdefinitiontemplate_->optional_glr_setting_->This()), GenerateVariable("\n\n%"), GenerateVariable("{"), GenerateVariable("\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <stdio"), GenerateVariable("."), GenerateVariable("h>\n#include <Deamer/External/Cpp/Lexer/TerminalObject"), GenerateVariable("."), GenerateVariable("h>\n#include <Deamer/External/Cpp/Ast/Node"), GenerateVariable("."), GenerateVariable("h>\n#include \""), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("/Bison/Parser"), GenerateVariable("."), GenerateVariable("h\"\n#define YY_NO_UNISTD_H\n#include \"Flex/"), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("_lexer"), GenerateVariable("."), GenerateVariable("h\"\n#undef YY_NO_UNISTD_H\n#include \""), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("/Ast/Enum/Type"), GenerateVariable("."), GenerateVariable("h\"\n"), GenerateVariable(parserdefinitiontemplate_->terminal_include_->Variable_Field()), GenerateVariable("\n\n"), GenerateVariable(parserdefinitiontemplate_->nonterminal_include_->Variable_Field()), GenerateVariable("\n\n#ifndef YY_parse_NERRS\n#define YY_parse_NERRS "), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("nerrs\n#endif //YY_parse_NERRS\n#ifndef YY_parse_LLOC\n#define YY_parse_LLOC "), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("lloc\n#endif //YY_parse_LLOC\n#define YYERROR_VERBOSE\n\nvoid "), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("error(const char* s);\nint "), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("lex();\nstatic ::deamer::external::cpp::ast::Tree* outputTree = nullptr;\n%"), GenerateVariable("}"), GenerateVariable("\n\n"), GenerateVariable(parserdefinitiontemplate_->terminal_declaration_->Variable_Field()), GenerateVariable("\n\n"), GenerateVariable(parserdefinitiontemplate_->nonterminal_declaration_->Variable_Field()), GenerateVariable("\n\n%union"), GenerateVariable("{"), GenerateVariable("\n\t::deamer::external::cpp::lexer::TerminalObject* Terminal;\n"), GenerateVariable(parserdefinitiontemplate_->union_declaration_->Variable_Field()), GenerateVariable("\n"), GenerateVariable("}"), GenerateVariable("\n\n%%\n\n"), GenerateVariable(parserdefinitiontemplate_->nonterminal_implementation_->Variable_Field()), GenerateVariable("\n\n%%\n\nvoid "), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("error(const char* s)\n"), GenerateVariable("{"), GenerateVariable("\n\tstd::cout << \"Syntax error on line: \" << s << '"), GenerateVariable("\\"), GenerateVariable("n';\n"), GenerateVariable("}"), GenerateVariable("\n\ndeamer::external::cpp::ast::Tree* "), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("::parser::Parser::Parse(const std::string& text) const\n"), GenerateVariable("{"), GenerateVariable("\n\toutputTree = nullptr;\n\tYY_BUFFER_STATE buf;\n\tbuf = "), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("_scan_string(text"), GenerateVariable("."), GenerateVariable("c_str());\n\t"), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("parse();\n\t"), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("_delete_buffer(buf);\n\t"), GenerateVariable(parserdefinitiontemplate_->language_name_->This()), GenerateVariable("lex_destroy();\n\n\treturn outputTree;\n"), GenerateVariable("}"), GenerateVariable("\n") }));
Content_->type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;

*static_cast<VariableBase*>(Class_postfix_) = VariableBase(std::vector<VariableBase*>({  }));
Class_postfix_->type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;

*static_cast<VariableBase*>(Extension_) = VariableBase(std::vector<VariableBase*>({ GenerateVariable("h") }));
Extension_->type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;

*static_cast<VariableBase*>(File_name_) = VariableBase(std::vector<VariableBase*>({ GenerateVariable("ParserDefinition") }));
File_name_->type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;

*static_cast<VariableBase*>(Namespace_) = VariableBase(std::vector<VariableBase*>({ GenerateVariable("deamer::templates::bison::parser") }));
Namespace_->type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;

*static_cast<VariableBase*>(Target_language_) = VariableBase(std::vector<VariableBase*>({ GenerateVariable("C++") }));
Target_language_->type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::Scope;


}


VariableBase* Content() const
{
	return Content_;
}

VariableBase* Class_postfix() const
{
	return Class_postfix_;
}

VariableBase* Extension() const
{
	return Extension_;
}

VariableBase* File_name() const
{
	return File_name_;
}

VariableBase* Namespace() const
{
	return Namespace_;
}

VariableBase* Target_language() const
{
	return Target_language_;
}


Variable_file_& operator=(const Variable_file_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	*Content_ = *variable.Content_;
*Class_postfix_ = *variable.Class_postfix_;
*Extension_ = *variable.Extension_;
*File_name_ = *variable.File_name_;
*Namespace_ = *variable.Namespace_;
*Target_language_ = *variable.Target_language_;


	return *this;
}

};

struct Variable_glr_setting_ : public VariableScopes
{

static constexpr auto name = "glr_setting_";



Variable_glr_setting_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::glr_setting_;
}

virtual ~Variable_glr_setting_() override = default;

Variable_glr_setting_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::glr_setting_;

}



Variable_glr_setting_& operator=(const Variable_glr_setting_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_ignore_section_ : public VariableScopes
{

static constexpr auto name = "ignore_section_";



Variable_ignore_section_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::ignore_section_;
}

virtual ~Variable_ignore_section_() override = default;

Variable_ignore_section_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::ignore_section_;

}



Variable_ignore_section_& operator=(const Variable_ignore_section_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_language_name_ : public VariableScopes
{

static constexpr auto name = "language_name_";



Variable_language_name_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::language_name_;
}

virtual ~Variable_language_name_() override = default;

Variable_language_name_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::language_name_;

}



Variable_language_name_& operator=(const Variable_language_name_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_left_angle_bracket_ : public VariableScopes
{

static constexpr auto name = "left_angle_bracket_";



Variable_left_angle_bracket_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_angle_bracket_;
}

virtual ~Variable_left_angle_bracket_() override = default;

Variable_left_angle_bracket_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_angle_bracket_;

}



Variable_left_angle_bracket_& operator=(const Variable_left_angle_bracket_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_left_bracket_ : public VariableScopes
{

static constexpr auto name = "left_bracket_";



Variable_left_bracket_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_bracket_;
}

virtual ~Variable_left_bracket_() override = default;

Variable_left_bracket_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_bracket_;

}



Variable_left_bracket_& operator=(const Variable_left_bracket_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_left_curly_bracket_ : public VariableScopes
{

static constexpr auto name = "left_curly_bracket_";



Variable_left_curly_bracket_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_curly_bracket_;
}

virtual ~Variable_left_curly_bracket_() override = default;

Variable_left_curly_bracket_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::left_curly_bracket_;

}



Variable_left_curly_bracket_& operator=(const Variable_left_curly_bracket_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_nonterminal_declaration_ : public VariableScopes
{

static constexpr auto name = "nonterminal_declaration_";



Variable_nonterminal_declaration_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_declaration_;
}

virtual ~Variable_nonterminal_declaration_() override = default;

Variable_nonterminal_declaration_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_declaration_;

}



Variable_nonterminal_declaration_& operator=(const Variable_nonterminal_declaration_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_nonterminal_implementation_ : public VariableScopes
{

static constexpr auto name = "nonterminal_implementation_";



Variable_nonterminal_implementation_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_implementation_;
}

virtual ~Variable_nonterminal_implementation_() override = default;

Variable_nonterminal_implementation_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_implementation_;

}



Variable_nonterminal_implementation_& operator=(const Variable_nonterminal_implementation_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_nonterminal_include_ : public VariableScopes
{

static constexpr auto name = "nonterminal_include_";



Variable_nonterminal_include_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_include_;
}

virtual ~Variable_nonterminal_include_() override = default;

Variable_nonterminal_include_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_include_;

}



Variable_nonterminal_include_& operator=(const Variable_nonterminal_include_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_nonterminal_token_name_ : public VariableScopes
{

static constexpr auto name = "nonterminal_token_name_";



Variable_nonterminal_token_name_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_token_name_;
}

virtual ~Variable_nonterminal_token_name_() override = default;

Variable_nonterminal_token_name_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::nonterminal_token_name_;

}



Variable_nonterminal_token_name_& operator=(const Variable_nonterminal_token_name_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_optional_comma_ : public VariableScopes
{

static constexpr auto name = "optional_comma_";



Variable_optional_comma_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_comma_;
}

virtual ~Variable_optional_comma_() override = default;

Variable_optional_comma_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_comma_;

}



Variable_optional_comma_& operator=(const Variable_optional_comma_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_optional_extended_error_ : public VariableScopes
{

static constexpr auto name = "optional_extended_error_";



Variable_optional_extended_error_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_extended_error_;
}

virtual ~Variable_optional_extended_error_() override = default;

Variable_optional_extended_error_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_extended_error_;

}



Variable_optional_extended_error_& operator=(const Variable_optional_extended_error_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_optional_glr_setting_ : public VariableScopes
{

static constexpr auto name = "optional_glr_setting_";



Variable_optional_glr_setting_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_glr_setting_;
}

virtual ~Variable_optional_glr_setting_() override = default;

Variable_optional_glr_setting_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_glr_setting_;

}



Variable_optional_glr_setting_& operator=(const Variable_optional_glr_setting_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_optional_or_ : public VariableScopes
{

static constexpr auto name = "optional_or_";



Variable_optional_or_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_or_;
}

virtual ~Variable_optional_or_() override = default;

Variable_optional_or_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_or_;

}



Variable_optional_or_& operator=(const Variable_optional_or_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_optional_parse_lac_ : public VariableScopes
{

static constexpr auto name = "optional_parse_lac_";



Variable_optional_parse_lac_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_parse_lac_;
}

virtual ~Variable_optional_parse_lac_() override = default;

Variable_optional_parse_lac_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_parse_lac_;

}



Variable_optional_parse_lac_& operator=(const Variable_optional_parse_lac_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_optional_top_nonterminal_output_ : public VariableScopes
{

static constexpr auto name = "optional_top_nonterminal_output_";



Variable_optional_top_nonterminal_output_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_top_nonterminal_output_;
}

virtual ~Variable_optional_top_nonterminal_output_() override = default;

Variable_optional_top_nonterminal_output_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::optional_top_nonterminal_output_;

}



Variable_optional_top_nonterminal_output_& operator=(const Variable_optional_top_nonterminal_output_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_or_ : public VariableScopes
{

static constexpr auto name = "or_";



Variable_or_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::or_;
}

virtual ~Variable_or_() override = default;

Variable_or_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::or_;

}



Variable_or_& operator=(const Variable_or_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_parse_lac_ : public VariableScopes
{

static constexpr auto name = "parse_lac_";



Variable_parse_lac_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::parse_lac_;
}

virtual ~Variable_parse_lac_() override = default;

Variable_parse_lac_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::parse_lac_;

}



Variable_parse_lac_& operator=(const Variable_parse_lac_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_production_rule_ : public VariableScopes
{

static constexpr auto name = "production_rule_";



Variable_production_rule_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_;
}

virtual ~Variable_production_rule_() override = default;

Variable_production_rule_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_;

}



Variable_production_rule_& operator=(const Variable_production_rule_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_production_rule_implementation_ : public VariableScopes
{

static constexpr auto name = "production_rule_implementation_";



Variable_production_rule_implementation_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_implementation_;
}

virtual ~Variable_production_rule_implementation_() override = default;

Variable_production_rule_implementation_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_implementation_;

}



Variable_production_rule_implementation_& operator=(const Variable_production_rule_implementation_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_production_rule_index_ : public VariableScopes
{

static constexpr auto name = "production_rule_index_";



Variable_production_rule_index_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_index_;
}

virtual ~Variable_production_rule_index_() override = default;

Variable_production_rule_index_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_index_;

}



Variable_production_rule_index_& operator=(const Variable_production_rule_index_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_production_rule_retrieved_tokens_ : public VariableScopes
{

static constexpr auto name = "production_rule_retrieved_tokens_";



Variable_production_rule_retrieved_tokens_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_retrieved_tokens_;
}

virtual ~Variable_production_rule_retrieved_tokens_() override = default;

Variable_production_rule_retrieved_tokens_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_retrieved_tokens_;

}



Variable_production_rule_retrieved_tokens_& operator=(const Variable_production_rule_retrieved_tokens_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_production_rule_retrieved_tokens_impl_ : public VariableScopes
{

static constexpr auto name = "production_rule_retrieved_tokens_impl_";



Variable_production_rule_retrieved_tokens_impl_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_retrieved_tokens_impl_;
}

virtual ~Variable_production_rule_retrieved_tokens_impl_() override = default;

Variable_production_rule_retrieved_tokens_impl_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_retrieved_tokens_impl_;

}



Variable_production_rule_retrieved_tokens_impl_& operator=(const Variable_production_rule_retrieved_tokens_impl_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_production_rule_type_ : public VariableScopes
{

static constexpr auto name = "production_rule_type_";



Variable_production_rule_type_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_type_;
}

virtual ~Variable_production_rule_type_() override = default;

Variable_production_rule_type_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::production_rule_type_;

}



Variable_production_rule_type_& operator=(const Variable_production_rule_type_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_right_angle_bracket_ : public VariableScopes
{

static constexpr auto name = "right_angle_bracket_";



Variable_right_angle_bracket_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_angle_bracket_;
}

virtual ~Variable_right_angle_bracket_() override = default;

Variable_right_angle_bracket_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_angle_bracket_;

}



Variable_right_angle_bracket_& operator=(const Variable_right_angle_bracket_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_right_bracket_ : public VariableScopes
{

static constexpr auto name = "right_bracket_";



Variable_right_bracket_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_bracket_;
}

virtual ~Variable_right_bracket_() override = default;

Variable_right_bracket_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_bracket_;

}



Variable_right_bracket_& operator=(const Variable_right_bracket_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_right_curly_bracket_ : public VariableScopes
{

static constexpr auto name = "right_curly_bracket_";



Variable_right_curly_bracket_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_curly_bracket_;
}

virtual ~Variable_right_curly_bracket_() override = default;

Variable_right_curly_bracket_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::right_curly_bracket_;

}



Variable_right_curly_bracket_& operator=(const Variable_right_curly_bracket_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_terminal_declaration_ : public VariableScopes
{

static constexpr auto name = "terminal_declaration_";



Variable_terminal_declaration_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::terminal_declaration_;
}

virtual ~Variable_terminal_declaration_() override = default;

Variable_terminal_declaration_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::terminal_declaration_;

}



Variable_terminal_declaration_& operator=(const Variable_terminal_declaration_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_terminal_include_ : public VariableScopes
{

static constexpr auto name = "terminal_include_";



Variable_terminal_include_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::terminal_include_;
}

virtual ~Variable_terminal_include_() override = default;

Variable_terminal_include_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::terminal_include_;

}



Variable_terminal_include_& operator=(const Variable_terminal_include_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_token_index_ : public VariableScopes
{

static constexpr auto name = "token_index_";



Variable_token_index_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::token_index_;
}

virtual ~Variable_token_index_() override = default;

Variable_token_index_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::token_index_;

}



Variable_token_index_& operator=(const Variable_token_index_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_token_name_ : public VariableScopes
{

static constexpr auto name = "token_name_";



Variable_token_name_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::token_name_;
}

virtual ~Variable_token_name_() override = default;

Variable_token_name_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::token_name_;

}



Variable_token_name_& operator=(const Variable_token_name_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_top_nonterminal_output_ : public VariableScopes
{

static constexpr auto name = "top_nonterminal_output_";



Variable_top_nonterminal_output_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::top_nonterminal_output_;
}

virtual ~Variable_top_nonterminal_output_() override = default;

Variable_top_nonterminal_output_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::top_nonterminal_output_;

}



Variable_top_nonterminal_output_& operator=(const Variable_top_nonterminal_output_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_transfer_nonterminal_ : public VariableScopes
{

static constexpr auto name = "transfer_nonterminal_";



Variable_transfer_nonterminal_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::transfer_nonterminal_;
}

virtual ~Variable_transfer_nonterminal_() override = default;

Variable_transfer_nonterminal_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::transfer_nonterminal_;

}



Variable_transfer_nonterminal_& operator=(const Variable_transfer_nonterminal_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_transfer_terminal_ : public VariableScopes
{

static constexpr auto name = "transfer_terminal_";



Variable_transfer_terminal_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::transfer_terminal_;
}

virtual ~Variable_transfer_terminal_() override = default;

Variable_transfer_terminal_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::transfer_terminal_;

}



Variable_transfer_terminal_& operator=(const Variable_transfer_terminal_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};

struct Variable_union_declaration_ : public VariableScopes
{

static constexpr auto name = "union_declaration_";



Variable_union_declaration_() : VariableScopes()
{
	type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::union_declaration_;
}

virtual ~Variable_union_declaration_() override = default;

Variable_union_declaration_(ParserDefinitionTemplate* parserdefinitiontemplate_, const std::vector<VariableBase*>& variables) : VariableScopes(variables)
{
type = ::deamer::templates::bison::parser::ParserDefinitionTemplate::Type::union_declaration_;

}



Variable_union_declaration_& operator=(const Variable_union_declaration_& variable)
{
	if (&variable == this)
	{
		return *this;
	}

	value = variable.value;
	isString = variable.isString;

	

	return *this;
}

};


	public:
		inline static std::vector<VariableBase*> variables_to_delete = std::vector<VariableBase*>();

	public:
		std::vector<VariableBase*> variables_;

	public:
		// Members that one can directly access.
		// e.g. ParserDefinitionTemplate.member = "auto-generated";
		Variable_extended_error_* extended_error_ = new Variable_extended_error_();
Variable_file_* file_ = new Variable_file_();
Variable_glr_setting_* glr_setting_ = new Variable_glr_setting_();
Variable_ignore_section_* ignore_section_ = new Variable_ignore_section_();
Variable_language_name_* language_name_ = new Variable_language_name_();
Variable_left_angle_bracket_* left_angle_bracket_ = new Variable_left_angle_bracket_();
Variable_left_bracket_* left_bracket_ = new Variable_left_bracket_();
Variable_left_curly_bracket_* left_curly_bracket_ = new Variable_left_curly_bracket_();
Variable_nonterminal_declaration_* nonterminal_declaration_ = new Variable_nonterminal_declaration_();
Variable_nonterminal_implementation_* nonterminal_implementation_ = new Variable_nonterminal_implementation_();
Variable_nonterminal_include_* nonterminal_include_ = new Variable_nonterminal_include_();
Variable_nonterminal_token_name_* nonterminal_token_name_ = new Variable_nonterminal_token_name_();
Variable_optional_comma_* optional_comma_ = new Variable_optional_comma_();
Variable_optional_extended_error_* optional_extended_error_ = new Variable_optional_extended_error_();
Variable_optional_glr_setting_* optional_glr_setting_ = new Variable_optional_glr_setting_();
Variable_optional_or_* optional_or_ = new Variable_optional_or_();
Variable_optional_parse_lac_* optional_parse_lac_ = new Variable_optional_parse_lac_();
Variable_optional_top_nonterminal_output_* optional_top_nonterminal_output_ = new Variable_optional_top_nonterminal_output_();
Variable_or_* or_ = new Variable_or_();
Variable_parse_lac_* parse_lac_ = new Variable_parse_lac_();
Variable_production_rule_* production_rule_ = new Variable_production_rule_();
Variable_production_rule_implementation_* production_rule_implementation_ = new Variable_production_rule_implementation_();
Variable_production_rule_index_* production_rule_index_ = new Variable_production_rule_index_();
Variable_production_rule_retrieved_tokens_* production_rule_retrieved_tokens_ = new Variable_production_rule_retrieved_tokens_();
Variable_production_rule_retrieved_tokens_impl_* production_rule_retrieved_tokens_impl_ = new Variable_production_rule_retrieved_tokens_impl_();
Variable_production_rule_type_* production_rule_type_ = new Variable_production_rule_type_();
Variable_right_angle_bracket_* right_angle_bracket_ = new Variable_right_angle_bracket_();
Variable_right_bracket_* right_bracket_ = new Variable_right_bracket_();
Variable_right_curly_bracket_* right_curly_bracket_ = new Variable_right_curly_bracket_();
Variable_terminal_declaration_* terminal_declaration_ = new Variable_terminal_declaration_();
Variable_terminal_include_* terminal_include_ = new Variable_terminal_include_();
Variable_token_index_* token_index_ = new Variable_token_index_();
Variable_token_name_* token_name_ = new Variable_token_name_();
Variable_top_nonterminal_output_* top_nonterminal_output_ = new Variable_top_nonterminal_output_();
Variable_transfer_nonterminal_* transfer_nonterminal_ = new Variable_transfer_nonterminal_();
Variable_transfer_terminal_* transfer_terminal_ = new Variable_transfer_terminal_();
Variable_union_declaration_* union_declaration_ = new Variable_union_declaration_();


	public:
		ParserDefinitionTemplate()
		{
			*extended_error_ = Variable_extended_error_(this, std::vector<VariableBase*>({ GenerateVariable("%define parse"), GenerateVariable("."), GenerateVariable("error verbose") }));
*file_ = Variable_file_(this, std::vector<VariableBase*>({  }));
*glr_setting_ = Variable_glr_setting_(this, std::vector<VariableBase*>({ GenerateVariable("%glr-parser") }));
*ignore_section_ = Variable_ignore_section_(this, std::vector<VariableBase*>({ GenerateVariable("\n\t\tdelete $"), GenerateVariable(token_index_->This()), GenerateVariable(";") }));
*language_name_ = Variable_language_name_(this, std::vector<VariableBase*>({  }));
*left_angle_bracket_ = Variable_left_angle_bracket_(this, std::vector<VariableBase*>({ GenerateVariable("<") }));
*left_bracket_ = Variable_left_bracket_(this, std::vector<VariableBase*>({ GenerateVariable("{") }));
*left_curly_bracket_ = Variable_left_curly_bracket_(this, std::vector<VariableBase*>({ GenerateVariable("(") }));
*nonterminal_declaration_ = Variable_nonterminal_declaration_(this, std::vector<VariableBase*>({ GenerateVariable("%nterm<"), GenerateVariable(language_name_->This()), GenerateVariable("_"), GenerateVariable(token_name_->This()), GenerateVariable("> "), GenerateVariable(token_name_->This()) }));
*nonterminal_implementation_ = Variable_nonterminal_implementation_(this, std::vector<VariableBase*>({ GenerateVariable("\n"), GenerateVariable(nonterminal_token_name_->This()), GenerateVariable(":"), GenerateVariable(production_rule_->Variable_Field()), GenerateVariable("\n;\n") }));
*nonterminal_include_ = Variable_nonterminal_include_(this, std::vector<VariableBase*>({ GenerateVariable("#include \""), GenerateVariable(language_name_->This()), GenerateVariable("/Ast/Node/"), GenerateVariable(token_name_->This()), GenerateVariable("."), GenerateVariable("h\"") }));
*nonterminal_token_name_ = Variable_nonterminal_token_name_(this, std::vector<VariableBase*>({  }));
*optional_comma_ = Variable_optional_comma_(this, std::vector<VariableBase*>({  }));
*optional_extended_error_ = Variable_optional_extended_error_(this, std::vector<VariableBase*>({ GenerateVariable(extended_error_->This()) }));
*optional_glr_setting_ = Variable_optional_glr_setting_(this, std::vector<VariableBase*>({  }));
*optional_or_ = Variable_optional_or_(this, std::vector<VariableBase*>({  }));
*optional_parse_lac_ = Variable_optional_parse_lac_(this, std::vector<VariableBase*>({ GenerateVariable(parse_lac_->This()) }));
*optional_top_nonterminal_output_ = Variable_optional_top_nonterminal_output_(this, std::vector<VariableBase*>({  }));
*or_ = Variable_or_(this, std::vector<VariableBase*>({ GenerateVariable("| ") }));
*parse_lac_ = Variable_parse_lac_(this, std::vector<VariableBase*>({ GenerateVariable("%define parse"), GenerateVariable("."), GenerateVariable("lac full") }));
*production_rule_ = Variable_production_rule_(this, std::vector<VariableBase*>({ GenerateVariable("\n\t"), GenerateVariable(optional_or_->This()), GenerateVariable(production_rule_implementation_->This()), GenerateVariable(" "), GenerateVariable("{"), GenerateVariable("\n\t\tauto* const newNode = new "), GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"), GenerateVariable(nonterminal_token_name_->This()), GenerateVariable("("), GenerateVariable("{"), GenerateVariable("::"), GenerateVariable(language_name_->This()), GenerateVariable("::ast::Type::"), GenerateVariable(nonterminal_token_name_->This()), GenerateVariable(", ::deamer::external::cpp::ast::NodeValue::nonterminal, "), GenerateVariable("{"), GenerateVariable(" "), GenerateVariable(production_rule_index_->This()), GenerateVariable(", ::deamer::external::cpp::ast::ProductionRuleType::"), GenerateVariable(production_rule_type_->This()), GenerateVariable(" "), GenerateVariable("}}"), GenerateVariable(", "), GenerateVariable("{"), GenerateVariable(" "), GenerateVariable(production_rule_retrieved_tokens_->Variable_Field()), GenerateVariable(" "), GenerateVariable("}"), GenerateVariable(");\n\t\t$$ = newNode;\n\n\t\t// Ignored, Deleted, tokens are deleted"), GenerateVariable(ignore_section_->Variable_Field()), GenerateVariable(optional_top_nonterminal_output_->This()), GenerateVariable("\n\t"), GenerateVariable("}") }));
*production_rule_implementation_ = Variable_production_rule_implementation_(this, std::vector<VariableBase*>({  }));
*production_rule_index_ = Variable_production_rule_index_(this, std::vector<VariableBase*>({  }));
*production_rule_retrieved_tokens_ = Variable_production_rule_retrieved_tokens_(this, std::vector<VariableBase*>({ GenerateVariable(optional_comma_->This()), GenerateVariable(production_rule_retrieved_tokens_impl_->This()) }));
*production_rule_retrieved_tokens_impl_ = Variable_production_rule_retrieved_tokens_impl_(this, std::vector<VariableBase*>({  }));
*production_rule_type_ = Variable_production_rule_type_(this, std::vector<VariableBase*>({  }));
*right_angle_bracket_ = Variable_right_angle_bracket_(this, std::vector<VariableBase*>({ GenerateVariable(">") }));
*right_bracket_ = Variable_right_bracket_(this, std::vector<VariableBase*>({ GenerateVariable("}") }));
*right_curly_bracket_ = Variable_right_curly_bracket_(this, std::vector<VariableBase*>({ GenerateVariable(")") }));
*terminal_declaration_ = Variable_terminal_declaration_(this, std::vector<VariableBase*>({ GenerateVariable("%token<Terminal> "), GenerateVariable(token_name_->This()) }));
*terminal_include_ = Variable_terminal_include_(this, std::vector<VariableBase*>({ GenerateVariable("#include \""), GenerateVariable(language_name_->This()), GenerateVariable("/Ast/Node/"), GenerateVariable(token_name_->This()), GenerateVariable("."), GenerateVariable("h\"") }));
*token_index_ = Variable_token_index_(this, std::vector<VariableBase*>({  }));
*token_name_ = Variable_token_name_(this, std::vector<VariableBase*>({  }));
*top_nonterminal_output_ = Variable_top_nonterminal_output_(this, std::vector<VariableBase*>({ GenerateVariable("\n\t\toutputTree = new ::deamer::external::cpp::ast::Tree(newNode);") }));
*transfer_nonterminal_ = Variable_transfer_nonterminal_(this, std::vector<VariableBase*>({ GenerateVariable("$"), GenerateVariable(token_index_->This()) }));
*transfer_terminal_ = Variable_transfer_terminal_(this, std::vector<VariableBase*>({ GenerateVariable("new "), GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"), GenerateVariable(token_name_->This()), GenerateVariable("("), GenerateVariable("{"), GenerateVariable("::"), GenerateVariable(language_name_->This()), GenerateVariable("::ast::Type::"), GenerateVariable(token_name_->This()), GenerateVariable(", ::deamer::external::cpp::ast::NodeValue::terminal, $"), GenerateVariable(token_index_->This()), GenerateVariable(" "), GenerateVariable("}"), GenerateVariable(")") }));
*union_declaration_ = Variable_union_declaration_(this, std::vector<VariableBase*>({ GenerateVariable("\t::"), GenerateVariable(language_name_->This()), GenerateVariable("::ast::node::"), GenerateVariable(token_name_->This()), GenerateVariable("* "), GenerateVariable(language_name_->This()), GenerateVariable("_"), GenerateVariable(token_name_->This()), GenerateVariable(";") }));


			variables_.emplace_back(extended_error_);
variables_.emplace_back(file_);
variables_.emplace_back(glr_setting_);
variables_.emplace_back(ignore_section_);
variables_.emplace_back(language_name_);
variables_.emplace_back(left_angle_bracket_);
variables_.emplace_back(left_bracket_);
variables_.emplace_back(left_curly_bracket_);
variables_.emplace_back(nonterminal_declaration_);
variables_.emplace_back(nonterminal_implementation_);
variables_.emplace_back(nonterminal_include_);
variables_.emplace_back(nonterminal_token_name_);
variables_.emplace_back(optional_comma_);
variables_.emplace_back(optional_extended_error_);
variables_.emplace_back(optional_glr_setting_);
variables_.emplace_back(optional_or_);
variables_.emplace_back(optional_parse_lac_);
variables_.emplace_back(optional_top_nonterminal_output_);
variables_.emplace_back(or_);
variables_.emplace_back(parse_lac_);
variables_.emplace_back(production_rule_);
variables_.emplace_back(production_rule_implementation_);
variables_.emplace_back(production_rule_index_);
variables_.emplace_back(production_rule_retrieved_tokens_);
variables_.emplace_back(production_rule_retrieved_tokens_impl_);
variables_.emplace_back(production_rule_type_);
variables_.emplace_back(right_angle_bracket_);
variables_.emplace_back(right_bracket_);
variables_.emplace_back(right_curly_bracket_);
variables_.emplace_back(terminal_declaration_);
variables_.emplace_back(terminal_include_);
variables_.emplace_back(token_index_);
variables_.emplace_back(token_name_);
variables_.emplace_back(top_nonterminal_output_);
variables_.emplace_back(transfer_nonterminal_);
variables_.emplace_back(transfer_terminal_);
variables_.emplace_back(union_declaration_);

		}

		virtual ~ParserDefinitionTemplate()
		{
			for(auto* variable : variables_to_delete)
			{
				delete variable;
			}

			variables_to_delete.clear();
		}

	public:
		// Default DST functions

		/*!	\fn GetOutput
		 *
		 *	\brief returns the output with the given the current state.
		 */
		std::string GetOutput()
		{
			return file_->Content()->GetValue();
		}

		/*!	\fn GetVariables
		 *
		 *	\brief Returns all top level variables known in this template.
		 */
		std::vector<VariableBase*> GetVariables()
		{
			return variables_;
		}

	public:
	};
}

#endif // DEAMER_TEMPLATES_BISON_PARSER_PARSERDEFINITIONTEMPLATE_h
